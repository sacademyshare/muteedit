<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ç„¡éŸ³åŒºé–“ã‚ªãƒ¼ãƒˆã‚«ãƒƒãƒˆï¼ˆGitHub Pages / ffmpeg.wasmï¼‰</title>
  <style>
    :root{ --bg:#0b0d10;--panel:#12161b;--muted:#8aa0b2;--text:#eaf2f9;--accent:#4aa3ff;--accent-2:#6ce1a6;--warn:#ffb86b;--err:#ff6b6b; }
    *{box-sizing:border-box}body{margin:0;font:15px/1.6 system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Noto Sans JP",Arial,sans-serif;background:var(--bg);color:var(--text)}
    header{padding:18px 20px;border-bottom:1px solid #1f2831;background:linear-gradient(180deg,#0d1117,#0a0e13)}
    h1{font-size:18px;margin:0}
    .container{max-width:1100px;margin:0 auto;padding:18px}
    .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:16px}
    video{width:100%;max-height:320px;background:#0c1116;border:1px solid #1e2a34;border-radius:10px;display:block}
    .card{background:var(--panel);border:1px solid #1e2a34;border-radius:14px;box-shadow:0 4px 24px rgba(0,0,0,.25)}
    .card h2{margin:0;padding:14px 16px;border-bottom:1px solid #1e2a34;font-size:16px}
    .card .body{padding:14px 16px}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    label{font-weight:600;color:#d5e2ee}
    input[type="file"]{padding:10px;border:1px dashed #2a3a47;border-radius:10px;background:#0e1318;color:#ddd}
    .controls{display:grid;gap:10px}
    .control{display:grid;grid-template-columns:160px 1fr auto;gap:10px;align-items:center}
    .control input[type=range]{width:100%}
    .hint{color:var(--muted);font-size:12px}
    button{appearance:none;border:none;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer;background:var(--accent);color:#001e36;transition:transform .04s ease,opacity .2s}
    button.secondary{background:#1e2a34;color:#cfe6ff}
    button:disabled{opacity:.5;cursor:not-allowed}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;font-size:12px}
    .progress{height:10px;background:#0c1116;border:1px solid #1e2a34;border-radius:999px;overflow:hidden}
    .progress>span{display:block;height:100%;width:0;background:linear-gradient(90deg,var(--accent),var(--accent-2));transition:width .2s}
    canvas{display:block;width:100%;height:140px;background:#0c1116;border:1px solid #1e2a34;border-radius:10px;cursor:crosshair}
    .badge{display:inline-block;padding:2px 8px;border:1px solid #34485a;border-radius:999px;font-size:12px;color:#c7d7e5;background:#0e151b}
    .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;background:#0e141a;border:1px solid #1e2a34;border-radius:999px}
    .footer{color:#8aa0b2;font-size:12px;padding:14px}
    .seglist{max-height:180px;overflow:auto;border:1px solid #1e2a34;border-radius:10px;padding:8px;background:#0e1318}
    .seglist div{padding:4px 6px;border-bottom:1px dashed #1e2a34}
    .seglist div:last-child{border-bottom:none}
    .error{color:var(--err)}
    .ok{color:var(--accent-2)}
    @media (max-width:960px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <header>
    <div class="container row" style="justify-content:space-between">
      <h1>ğŸ¬ ç„¡éŸ³ã‚«ãƒƒãƒˆè‡ªå‹•åŒ–ï¼ˆGitHub Pages / ffmpeg.wasmï¼‰</h1>
      <div class="pill"><span class="badge">Free</span><span class="badge">Client-side</span><span class="badge">Safari/Chrome</span></div>
    </div>
  </header>

  <div class="container grid">
    <section class="card">
      <h2>â‘  å‹•ç”»ã‚’é¸æŠ & è§£æ / ãƒ©ã‚¤ãƒ–ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h2>
      <div class="body">
        <div class="row" style="justify-content:space-between">
          <div>
            <label for="file">å…¥åŠ›å‹•ç”»ï¼ˆPC/iPadï¼‰</label><br>
            <input type="file" id="file" accept="video/*" />
            <div class="hint">å¤§ããªå‹•ç”»ã¯ç«¯æœ«ãƒ¡ãƒ¢ãƒªã‚’å¤šãæ¶ˆè²»ã—ã¾ã™ï¼ˆæ¨å¥¨: 20åˆ†ãƒ»1GBä»¥ä¸‹ï¼‰ã€‚</div>
          </div>
          <div>
            <button id="analyzeBtn" class="secondary" disabled>éŸ³é‡ã‚’è§£æã™ã‚‹</button>
          </div>
        </div>

        <div style="margin-top:12px">
          <canvas id="wave" title="ã‚¯ãƒªãƒƒã‚¯ã§ã‚·ãƒ¼ã‚¯ / ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ã‚ºãƒ¼ãƒ è§£é™¤"></canvas>
          <div class="hint">æ³¢å½¢ã¯ <span class="mono">dBFS</span>ï¼ˆ0=æœ€å¤§ã€è² ã®å€¤=å°ã•ã„ï¼‰ã€‚<b>é’ç·š=ã—ãã„å€¤</b>ã€<b>ç·‘å¸¯=ä¿æŒåŒºé–“</b>ã€‚</div>
        </div>

        <div class="controls" style="margin-top:12px">
          <div class="control">
            <label>ã—ãã„å€¤ï¼ˆdBFSï¼‰</label>
            <input type="range" id="thresh" min="-90" max="0" step="1" value="-40" />
            <span id="threshVal" class="mono">-40 dB</span>
          </div>
          <div class="control">
            <label>æœ€å°ç„¡éŸ³é•·ï¼ˆmsï¼‰</label>
            <input type="range" id="minSil" min="50" max="4000" step="50" value="300" />
            <span id="minSilVal" class="mono">300 ms</span>
          </div>
          <div class="control">
            <label>å‰å¾Œãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆmsï¼‰</label>
            <input type="range" id="pad" min="0" max="1000" step="50" value="120" />
            <span id="padVal" class="mono">120 ms</span>
          </div>
          <div class="control">
            <label>è§£æçª“å¹…ï¼ˆmsï¼‰</label>
            <input type="range" id="win" min="10" max="200" step="10" value="40" />
            <span id="winVal" class="mono">40 ms</span>
          </div>
          <div class="control">
            <label>ãƒ©ã‚¤ãƒ–å†è§£æ</label>
            <label class="row" style="gap:8px"><input type="checkbox" id="live" checked> ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼æ“ä½œã§å³ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°</label>
            <span class="hint">è² è·ãŒé«˜ã„å ´åˆã¯OFFã«ã—ã¦ãã ã•ã„</span>
          </div>
        </div>

        <div class="row" style="margin-top:8px;justify-content:space-between;align-items:center">
          <label class="row" style="gap:8px"><input type="checkbox" id="previewToggle" disabled> ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§ç„¡éŸ³ã‚’ã‚¹ã‚­ãƒƒãƒ—</label>
          <div class="row" style="gap:8px">
            <button id="previewStart" class="secondary" disabled>â–¶ å†ç”Ÿ</button>
            <button id="previewStop" class="secondary" disabled>â¸ åœæ­¢</button>
          </div>
        </div>
        <video id="player" controls playsinline preload="metadata" muted></video>
        <div class="hint">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¯<b>å†ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã›ãš</b>ã«ä¿æŒåŒºé–“ã ã‘é€£ç¶šå†ç”Ÿã—ã¾ã™ã€‚</div>

        <div style="margin-top:8px" class="row">
          <button id="recalcBtn" class="secondary" disabled>æ‰‹å‹•ã§å†è¨ˆç®—</button>
          <span id="analysisMeta" class="hint"></span>
        </div>
      </div>
    </section>

    <section class="card">
      <h2>â‘¡ è‡ªå‹•ã‚«ãƒƒãƒˆ & æ›¸ãå‡ºã—ï¼ˆMP4ï¼‰</h2>
      <div class="body">
        <div class="row" style="justify-content:space-between">
          <button id="cutBtn" disabled>ç„¡éŸ³ã‚’ã‚«ãƒƒãƒˆã—ã¦æ›¸ãå‡ºã—</button>
          <div class="row" style="gap:8px">
            <span class="badge">H.264 + AAC</span>
            <span class="badge">å¯å¤‰ãƒ¬ãƒ¼ãƒˆ</span>
          </div>
        </div>

        <div class="row" style="margin-top:10px;gap:14px;align-items:flex-end">
          <div>
            <label>å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«å</label><br>
            <input id="outNameInput" type="text" value="cut_output.mp4" style="width:260px;padding:8px;border-radius:10px;border:1px solid #1e2a34;background:#0e1318;color:#eaf2f9" />
            <div class="hint">æ‹¡å¼µå­ã¯ <span class="mono">.mp4</span> æ¨å¥¨</div>
          </div>
          <div>
            <label>ç”»è³ªï¼ˆCRFï¼‰</label><br>
            <input type="range" id="crf" min="18" max="30" step="1" value="22" style="width:220px" />
            <span id="crfVal" class="mono">CRF 22</span>
            <div class="hint">å°ã•ã„ã»ã©é«˜ç”»è³ªãƒ»ãƒ•ã‚¡ã‚¤ãƒ«å¤§</div>
          </div>
          <div>
            <label>ãƒ—ãƒªã‚»ãƒƒãƒˆ</label><br>
            <select id="preset" style="padding:8px;border-radius:10px;border:1px solid #1e2a34;background:#0e1318;color:#eaf2f9">
              <option value="veryfast" selected>veryfast</option>
              <option value="faster">faster</option>
              <option value="fast">fast</option>
              <option value="medium">medium</option>
            </select>
          </div>
          <div>
            <label>éŸ³å£°ãƒ“ãƒƒãƒˆãƒ¬ãƒ¼ãƒˆ</label><br>
            <select id="abitrate" style="padding:8px;border-radius:10px;border:1px solid #1e2a34;background:#0e1318;color:#eaf2f9">
              <option value="128k">128k</option>
              <option value="160k">160k</option>
              <option value="192k" selected>192k</option>
              <option value="256k">256k</option>
            </select>
          </div>
        </div>

        <div style="margin:10px 0" class="progress"><span id="prog"></span></div>
        <div id="log" class="mono hint" style="white-space:pre-wrap;max-height:160px;overflow:auto"></div>

        <h3 style="margin:12px 0 6px">ä¿æŒåŒºé–“ï¼ˆéŸ³ãŒã‚ã‚‹ã¨åˆ¤æ–­ï¼‰</h3>
        <div id="segList" class="seglist hint">è§£æå¾Œã«è¡¨ç¤ºã•ã‚Œã¾ã™â€¦</div>

        <div id="outWrap" style="margin-top:12px"></div>
        <div class="footer">â€» ã™ã¹ã¦ç«¯æœ«å†…ã§å‡¦ç†ã—ã¾ã™ã€‚ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã¯è¡Œã„ã¾ã›ã‚“ã€‚</div>
      </div>
    </section>
  </div>

  <div class="container" style="margin-top:-6px">
    <section class="card">
      <h2>è£œè¶³ï¼ˆå®Ÿè£…ã®è¦ç‚¹ & è¨ºæ–­ï¼‰</h2>
      <div class="body">
        <ul>
          <li>Web Audio API ã§çŸ­æ™‚é–“RMS â†’ dBFSåŒ–ã—ã€<strong>ã—ãã„å€¤</strong>ãƒ»<strong>ç„¡éŸ³é•·</strong>ãƒ»<strong>å‰å¾Œãƒ‘ãƒ‡ã‚£ãƒ³ã‚°</strong>ã§ä¿æŒåŒºé–“ã‚’æŠ½å‡ºã€‚</li>
          <li>ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¯ä¿æŒåŒºé–“ã®ã¿ã‚’é€£ç¶šå†ç”Ÿã€‚<b>æ›¸ãå‡ºã—ã¯ã“ã®æŒ™å‹•ã‚’ãã®ã¾ã¾éŒ²ç”»</b>ã—ã€MP4ä¿å­˜ï¼ˆSafariç­‰ã¯MP4ç›´éŒ²ã€ä»–ã¯WebMâ†’ffmpeg.wasmã§MP4å¤‰æ›ï¼‰ã€‚</li>
          <li>ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯äº‹æƒ…ã§å ´æ‰€ãŒé•ã†æ™‚ã¯ã€URLã« <code>?ffbase=./path/to/</code> ã‚’ä»˜ã‘ã¦ãã ã•ã„ã€‚</li>
        </ul>
        <button id="diagBtn" class="secondary">ç’°å¢ƒè¨ºæ–­ã‚’å®Ÿè¡Œ</button>
      </div>
    </section>
  </div>

  <!-- â˜… ffmpeg UMDãƒ­ãƒ¼ãƒ€ï¼ˆPageså‘ã‘ï¼‰ï¼šbaseæ­£è¦åŒ–ãƒ»æ—¢å®šå€¤ãƒ»FFmpegWASMâ†’FFmpeg shim -->
  <script>
    // --- base ã®æ­£è¦åŒ–ã¨æ—¢å®šå€¤ ---
    function sanitizeBase(b){
      if(!b) return b;
      b = b.replace(/^\?ffbase=/,'').replace(/^\?/,'');
      return b.endsWith('/') ? b : b + '/';
    }
    function getFFBaseOverride() {
      const u = new URL(location.href);
      const p = u.searchParams.get('ffbase');
      if (p) {
        const v = sanitizeBase(p);
        localStorage.setItem('ffbase', v);
        return v;
      }
      const s = localStorage.getItem('ffbase');
      return s ? sanitizeBase(s) : null;
    }
    const hereDir = location.pathname.replace(/[^/]+$/,'');
    if (location.hostname.endsWith('.github.io') && !window.__FFBASE_DEFAULT__) {
      const repo = '/' + location.pathname.split('/')[1] + '/';
      window.__FFBASE_DEFAULT__ = repo + 'assets/ffmpeg/';
    }
    function absolutePagesBase() {
      const repo = '/' + location.pathname.split('/')[1] + '/';
      return repo + 'assets/ffmpeg/';
    }
    function buildCandidates(){
      const set = new Set();
      if (location.hostname.endsWith('.github.io')) set.add(absolutePagesBase());
      const ov = getFFBaseOverride(); if (ov) set.add(ov);
      if (window.__FFBASE_DEFAULT__) set.add(window.__FFBASE_DEFAULT__);
      [ './assets/ffmpeg/','./ffmpeg/', hereDir + 'assets/ffmpeg/', hereDir + 'ffmpeg/', '../assets/ffmpeg/','../../assets/ffmpeg/' ]
        .forEach(b => set.add(b.endsWith('/') ? b : (b + '/')));
      return Array.from(set);
    }
    function loadScript(src, timeoutMs=8000){
      return new Promise((resolve,reject)=>{
        const s=document.createElement('script'); s.src=src; s.async=true;
        let done=false;
        const tid=setTimeout(()=>{ if(done) return; done=true; s.remove(); reject(new Error('Timeout: '+src)); }, timeoutMs);
        s.onload=()=>{ if(done) return; done=true; clearTimeout(tid); resolve(); };
        s.onerror=()=>{ if(done) return; done=true; clearTimeout(tid); reject(new Error('Failed: '+src)); };
        document.head.appendChild(s);
      });
    }
    // --- FFmpegWASM â†’ window.FFmpeg shim ---
    function ensureFFmpegShim(ffbase){
      if (window.FFmpeg && typeof window.FFmpeg.createFFmpeg==='function') return;
      if (!window.FFmpegWASM || !window.FFmpegWASM.FFmpeg) return;
      if (ffbase && !ffbase.endsWith('/')) ffbase += '/';
      function createFFmpeg(opts){
        const core = new window.FFmpegWASM.FFmpeg();
        let logger=null, progress=null;
        core.on('log',     (m)=>{ if(logger)   logger({ type:'info', message:String(m && m.message!==undefined? m.message : m) }); });
        core.on('progress',(p)=>{ const r = (p&&typeof p.ratio==='number')? p.ratio : 0; if(progress) progress({ratio:r}); });
        return {
          load: ()=>core.load({
            coreURL:   (opts && (opts.corePath || opts.coreURL)) || (ffbase + 'ffmpeg-core.js'),
            wasmURL:   (opts && opts.wasmPath)   || (ffbase + 'ffmpeg-core.wasm'),
            workerURL: (opts && opts.workerPath) || (ffbase + 'ffmpeg-core.worker.js')
          }),
          run: (...argv)=>core.exec(argv),
          FS: (op, ...rest)=>{
            switch(op){
              case 'writeFile': return core.writeFile(rest[0], rest[1]);
              case 'readFile' : return core.readFile(rest[0], 'binary');
              case 'unlink'   : return core.deleteFile(rest[0]);
              case 'readdir'  : return core.listDir(rest[0]);
              case 'mkdir'    : return core.createDir(rest[0]);
              case 'rmdir'    : return core.deleteDir(rest[0]);
              default: throw new Error('Unsupported FS op in shim: '+op);
            }
          },
          setLogger:   (fn)=>{ logger=fn; },
          setProgress: (fn)=>{ progress=fn; },
          terminate:   ()=>{ try{ core.terminate(); }catch(_){} }
        };
      }
      async function fetchFile(input){
        if (input instanceof Uint8Array) return input;
        if (typeof Blob!=='undefined' && input instanceof Blob) return new Uint8Array(await input.arrayBuffer());
        if (typeof input==='string'){ const res=await fetch(input); return new Uint8Array(await res.arrayBuffer()); }
        if (input && typeof input.arrayBuffer==='function') return new Uint8Array(await input.arrayBuffer());
        throw new Error('Unsupported input for fetchFile');
      }
      window.FFmpeg = { createFFmpeg, fetchFile };
    }
    async function tryLoadLocalUMD(bases){
      const tried=[];
      for (const base of bases){
        const url = base + 'ffmpeg.min.js';
        console.log('[UMD/local] try:', url); tried.push(url);
        try{
          await loadScript(url, 8000);
          ensureFFmpegShim(base);
          if (!(window.FFmpeg && window.FFmpeg.createFFmpeg && window.FFmpeg.fetchFile)){
            throw new Error('FFmpeg global missing after load');
          }
          console.log('[UMD/local] loaded:', url);
          window.__FFBASE_SELECTED__ = base;
          return base;
        }catch(e){
          console.warn('[UMD/local] failed:', e.message);
        }
      }
      const logEl=document.getElementById('log');
      if(logEl){
        logEl.textContent += '\nâŒ ffmpeg.min.js æ¢ç´¢å¤±æ•—ã€‚è©¦è¡ŒURL:\n- ' + tried.join('\n- ');
        logEl.scrollTop = logEl.scrollHeight;
      }
      throw new Error('åŒä¸€ã‚ªãƒªã‚¸ãƒ³ã® ffmpeg.min.js ã‚’èª­ã‚ã¾ã›ã‚“ã§ã—ãŸï¼ˆé…ç½®ãƒ‘ã‚¹/ãƒ•ã‚¡ã‚¤ãƒ«å/MIMEã‚’ç¢ºèªï¼‰');
    }
    async function loadFFmpegLocalWithPrompt(){
      try{
        return await tryLoadLocalUMD(buildCandidates());
      }catch(e){
        const hint='ffmpeg.min.js ã®ã‚ã‚‹ãƒ•ã‚©ãƒ«ãƒ€URLã‚’å…¥åŠ›ï¼ˆä¾‹: ./assets/ffmpeg/ ã‚„ /<repo>/assets/ffmpeg/ ãªã©ï¼‰ã€‚\næ¬¡å›ä»¥é™ã¯ localStorage ã® ffbase ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚';
        const manual = prompt(hint, localStorage.getItem('ffbase') || (window.__FFBASE_DEFAULT__||'./assets/ffmpeg/'));
        if(manual){
          const base = sanitizeBase(manual);
          localStorage.setItem('ffbase', base);
          return await tryLoadLocalUMD([base]);
        }
        throw e;
      }
    }
    async function urlOk(u) {
      try { const r = await fetch(u, { method: 'HEAD', cache: 'no-store' }); return r.ok; }
      catch { return false; }
    }
    async function pickWorkingFFBase(bases) {
      const coreNames = ['ffmpeg-core.js', 'ffmpeg-core.mjs'];
      for (const base of bases) {
        for (const name of coreNames) {
          if (await urlOk(base + name)) return { base, core: name };
        }
      }
      throw new Error('ffmpeg-core(.js|.mjs) ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚é…ç½®/å…¬é–‹ãƒ–ãƒ©ãƒ³ãƒã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
    }
  </script>

  <!-- â˜… ã‚¢ãƒ—ãƒªæœ¬ä½“ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¨åŒã˜æŒ™å‹•ã‚’éŒ²ç”»ã—MP4ã«ä¿å­˜ï¼‰ -->
  <script>
    // å¤šé‡åˆæœŸåŒ–ã‚¬ãƒ¼ãƒ‰
    if (window.__MUTEEDIT_INITED__) {
      console.warn('[muteedit] script already initialized; skipping re-init');
    } else {
      window.__MUTEEDIT_INITED__ = true;

      const els = {
        file: document.getElementById('file'),
        analyze: document.getElementById('analyzeBtn'),
        recalc: document.getElementById('recalcBtn'),
        cut: document.getElementById('cutBtn'),
        wave: document.getElementById('wave'),
        segList: document.getElementById('segList'),
        thresh: document.getElementById('thresh'),
        threshVal: document.getElementById('threshVal'),
        minSil: document.getElementById('minSil'),
        minSilVal: document.getElementById('minSilVal'),
        pad: document.getElementById('pad'),
        padVal: document.getElementById('padVal'),
        win: document.getElementById('win'),
        winVal: document.getElementById('winVal'),
        live: document.getElementById('live'),
        analysisMeta: document.getElementById('analysisMeta'),
        log: document.getElementById('log'),
        prog: document.getElementById('prog'),
        outWrap: document.getElementById('outWrap'),
        player: document.getElementById('player'),
        previewToggle: document.getElementById('previewToggle'),
        previewStart: document.getElementById('previewStart'),
        previewStop: document.getElementById('previewStop'),
        outNameInput: document.getElementById('outNameInput'),
        crf: document.getElementById('crf'),
        crfVal: document.getElementById('crfVal'),
        preset: document.getElementById('preset'),
        abitrate: document.getElementById('abitrate'),
        makeProxyBtn: document.getElementById('makeProxyBtn'),
        proxyHint: document.getElementById('proxyHint'),
        diagBtn: document.getElementById('diagBtn'),
      };
      function log(msg){ els.log.textContent += `\n${msg}`; els.log.scrollTop=els.log.scrollHeight; }
      function error(msg){ log(`âŒ ${msg}`); }

      // æ—¢å­˜ã‚¤ãƒ™ãƒ³ãƒˆã‚’å®Œå…¨é™¤å»ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚„äºŒé‡èª­ã¿å¯¾ç­–ï¼‰
      function resetDomEventTarget(el) {
        const fresh = el.cloneNode(true);
        el.parentNode.replaceChild(fresh, el);
        return fresh;
      }
      els.cut          = resetDomEventTarget(els.cut);
      els.previewStart = resetDomEventTarget(els.previewStart);
      els.previewStop  = resetDomEventTarget(els.previewStop);

      let decoded=null, analysis=null, keepSegments=[], inputBlobURL=null;
      let previewOn=false, previewHandlersBound=false;

      // ffmpeg
      let ffmpeg=null, ffmpegReady=false, FF_BASE=null, FF_CORE_FILE='ffmpeg-core.js';

      function ensureCutState(){ els.cut.disabled = !(decoded && analysis); }
      let recomputeTimer=null; function debouncedRecompute(){ clearTimeout(recomputeTimer); recomputeTimer=setTimeout(()=>computeAnalysis(),160); }

      // ====== FFmpeg ãƒ­ãƒ¼ãƒ‰ï¼ˆå­˜åœ¨ç¢ºèª â†’ è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¯¾å¿œï¼‰======
      async function ensureFFmpeg(){
        if (ffmpegReady) return;
        let umdBase;
        try { umdBase = await loadFFmpegLocalWithPrompt(); }
        catch(e) { error(e.message + '\nãƒ’ãƒ³ãƒˆ: URLæœ«å°¾ã« ?ffbase=/'+location.pathname.split('/')[1]+'/assets/ffmpeg/ ã‚’ä»˜ã‘ã¦å†èª­ã¿è¾¼ã¿'); throw e; }

        const headCandidates = [];
        if (location.hostname.endsWith('.github.io')) headCandidates.push(absolutePagesBase());
        headCandidates.push(umdBase, ...buildCandidates());

        try {
          const picked = await pickWorkingFFBase(headCandidates);
          FF_BASE = picked.base; FF_CORE_FILE = picked.core;
        } catch (e) {
          localStorage.removeItem('ffbase');
          const picked = await pickWorkingFFBase(buildCandidates());
          FF_BASE = picked.base; FF_CORE_FILE = picked.core;
        }

        if (!(window.FFmpeg && FFmpeg.createFFmpeg && FFmpeg.fetchFile)){
          throw new Error('FFmpeg ã‚°ãƒ­ãƒ¼ãƒãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆUMDã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ï¼‰');
        }

        const { createFFmpeg } = FFmpeg;
        ffmpeg = createFFmpeg({
          corePath:   FF_BASE + FF_CORE_FILE,
          workerPath: FF_BASE + 'ffmpeg-core.worker.js',
          log: true,
          logger: ({ type, message }) => { els.log.textContent += `\n[ffmpeg:${type}] ${message}`; els.log.scrollTop = els.log.scrollHeight; },
          progress: ({ ratio }) => { const r = Number.isFinite(ratio)?Math.min(1,Math.max(0,ratio)):0; els.prog.style.width = `${r*100}%`; }
        });

        log(`ffmpeg.wasm èµ·å‹•ä¸­ï¼ˆbase=${FF_BASE} core=${FF_CORE_FILE}ï¼‰â€¦`);
        await ffmpeg.load();
        ffmpegReady=true; log('ffmpeg.wasm æº–å‚™å®Œäº†');
      }

      const syncLabels=()=>{
        els.threshVal.textContent = `${els.thresh.value} dB`;
        els.minSilVal.textContent = `${els.minSil.value} ms`;
        els.padVal.textContent = `${els.pad.value} ms`;
        els.winVal.textContent = `${els.win.value} ms`;
        els.crfVal.textContent = `CRF ${els.crf.value}`;
      };
      ['thresh','minSil','pad','win','crf'].forEach(id=>els[id].addEventListener('input',()=>{
        syncLabels();
        if(els.live.checked && decoded) debouncedRecompute();
        else drawWave(analysis?.dbfs||[]);
      }));
      syncLabels();

      els.file.addEventListener('change',()=>{
        const f = els.file.files?.[0];
        if(!f){ els.analyze.disabled=true; ensureCutState(); return; }
        els.analyze.disabled=false; els.recalc.disabled=true;
        decoded=null; analysis=null; keepSegments=[];
        drawWave([]); els.segList.textContent='è§£æå¾…ã¡â€¦'; els.outWrap.innerHTML='';
        ensureCutState(); log(`é¸æŠ: ${f.name} (${(f.size/1e6).toFixed(1)} MB)`);
        if(inputBlobURL) URL.revokeObjectURL(inputBlobURL);
        inputBlobURL = URL.createObjectURL(f);
        els.player.src=inputBlobURL; els.player.load();
        els.previewStart.disabled=false; els.previewStop.disabled=false; els.previewToggle.disabled=true;
      });

      els.analyze.addEventListener('click', async()=>{
        const file = els.file.files?.[0]; if(!file) return;
        els.analyze.disabled=true; log('éŸ³å£°ãƒ‡ã‚³ãƒ¼ãƒ‰ä¸­â€¦');
        try{
          const ac = new (window.AudioContext||window.webkitAudioContext)();
          const buf = await ac.decodeAudioData(await file.arrayBuffer());
          decoded = {audioBuffer:buf, duration:buf.duration};
          log(`Audio decoded: ${buf.duration.toFixed(3)} sec, ch=${buf.numberOfChannels}, sr=${buf.sampleRate}`);
          await computeAnalysis();
          els.recalc.disabled=false; els.previewToggle.disabled=false; els.previewStart.disabled=false; els.previewStop.disabled=false;
        }catch(err){ error(`ãƒ‡ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—: ${err?.message||err}`); els.analyze.disabled=false; }
        finally{ ensureCutState(); }
      });

      els.recalc.addEventListener('click', async()=>{ if(!decoded) return; await computeAnalysis(); });

      async function computeAnalysis(){
        if(!decoded){ ensureCutState(); return; }
        try{
          const {audioBuffer, duration} = decoded; const sr=audioBuffer.sampleRate; const ch=audioBuffer.numberOfChannels;
          const winMs=+els.win.value; const stepSamples=Math.max(1,Math.round((winMs/1000)*sr));
          const len=Math.ceil(audioBuffer.length/stepSamples); const dbfs=new Float32Array(len);
          const eps=1e-12; const chData=Array.from({length:ch},(_,i)=>audioBuffer.getChannelData(i));
          let idx=0; for(let s=0;s<audioBuffer.length;s+=stepSamples){
            const end=Math.min(s+stepSamples,audioBuffer.length); let sumsq=0,count=0;
            for(let i=s;i<end;i++){ let sample=0; for(let c=0;c<ch;c++) sample+=chData[c][i]||0; sample/=ch; sumsq+=sample*sample; count++; }
            const rms=Math.sqrt(sumsq/Math.max(1,count)); dbfs[idx++]=20*Math.log10(Math.max(rms,eps));
          }
          analysis={dbfs, stepSec:stepSamples/sr, duration};

          const thr=+els.thresh.value; const minSil=+els.minSil.value/1000; const pad=+els.pad.value/1000;
          keepSegments=buildKeepSegments(dbfs,analysis.stepSec,duration,thr,minSil,pad);
          els.analysisMeta.textContent=`æ¤œå‡ºã‚¦ã‚£ãƒ³ãƒ‰ã‚¦: ${winMs}ms, ã‚µãƒ³ãƒ—ãƒ«æ•°: ${dbfs.length}, æ®‹ã™åŒºé–“: ${keepSegments.length} å€‹`;
          drawWave(dbfs); renderSegments();

          ensureCutState();
          if(keepSegments.length>0) els.cut.disabled=false;

          if(previewOn){
            const seg=withinKeep(els.player.currentTime);
            if(!seg && keepSegments[0]) els.player.currentTime=keepSegments[0].start;
          }
        }catch(e){ error(`è§£æã‚¨ãƒ©ãƒ¼: ${e?.message||e}`); }
        finally{ ensureCutState(); }
      }

      function buildKeepSegments(dbfs, step, duration, thr, minSil, pad){
        const mask=dbfs.map(v=>v>=thr?1:0); const segs=[]; let runStart=null;
        for(let i=0;i<mask.length;i++){
          if(mask[i]===1 && runStart===null) runStart=i;
          if((mask[i]===0 || i===mask.length-1) && runStart!==null){
            const last=(mask[i]===0?i-1:i); const st=runStart*step; const en=Math.min((last+1)*step,duration);
            segs.push({start:st,end:en}); runStart=null;
          }
        }
        const merged=[]; for(const s of segs){ const prev=merged[merged.length-1];
          if(prev && s.start-prev.end<minSil) prev.end=s.end; else merged.push({...s}); }
        return merged.map(s=>({start:Math.max(0,s.start-pad), end:Math.min(duration,s.end+pad)}));
      }

      function drawWave(dbfs){
        const canvas=els.wave; const dpr=window.devicePixelRatio||1; const W=canvas.clientWidth; const H=canvas.clientHeight;
        canvas.width=Math.floor(W*dpr); canvas.height=Math.floor(H*dpr); const ctx=canvas.getContext('2d');
        ctx.setTransform(dpr,0,0,dpr,0,0); ctx.clearRect(0,0,W,H);
        ctx.strokeStyle='#1f2a35'; ctx.lineWidth=1; ctx.beginPath(); for(let y=0;y<=4;y++){ const yy=(H-20)*(y/4)+10; ctx.moveTo(8,yy); ctx.lineTo(W-8,yy);} ctx.stroke();
        const toY=v=>{ const clamped=Math.max(-90,Math.min(0,v||-90)); const t=(clamped+90)/90; return 10+(1-t)*(H-20); };
        const tToX=t=>10+((t/(analysis?.duration||1))*(W-20));
        if(analysis && keepSegments.length){ ctx.fillStyle='rgba(108,225,166,0.18)'; keepSegments.forEach(s=>{ const x1=tToX(s.start),x2=tToX(s.end); ctx.fillRect(x1,10,Math.max(1,x2-x1),H-20); }); }
        if(dbfs && dbfs.length){ ctx.strokeStyle='#6ce1a6'; ctx.lineWidth=1; ctx.beginPath(); for(let i=0;i<dbfs.length;i++){ const x=10+(i/(dbfs.length-1))*(W-20); const y=toY(dbfs[i]); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke(); }
        const thr=+els.thresh.value; const ythr=toY(thr); ctx.strokeStyle='#4aa3ff'; ctx.setLineDash([4,4]); ctx.beginPath(); ctx.moveTo(8,ythr); ctx.lineTo(W-8,ythr); ctx.stroke(); ctx.setLineDash([]);
      }

      function renderSegments(){
        if(!keepSegments.length){ els.segList.innerHTML='<div>æ¤œå‡ºã•ã‚ŒãŸä¿æŒåŒºé–“ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã—ãã„å€¤ã‚’ä¸‹ã’ã¦ãã ã•ã„ã€‚</div>'; return; }
        const fmt=t=> new Date(t*1000).toISOString().substring(11,23);
        els.segList.innerHTML=keepSegments.map((s,i)=>`<div>#${i+1} <span class="mono">${fmt(s.start)}</span> â†’ <span class="mono">${fmt(s.end)}</span> <span class="hint">(${(s.end-s.start).toFixed(2)}s)</span></div>`).join('');
      }

      function withinKeep(t){ for(const seg of keepSegments){ if(t>=seg.start && t<seg.end) return seg; } return null; }
      function nextKeepStartAfter(t){ for(const seg of keepSegments){ if(seg.end<=t) continue; if(t<seg.start) return seg.start; } return null; }
      function bindPreviewHandlers(){
        if(previewHandlersBound) return;
        els.player.addEventListener('timeupdate',()=>{ if(!previewOn || !keepSegments.length) return;
          const t=els.player.currentTime; const seg=withinKeep(t);
          if(!seg){ const nextStart=nextKeepStartAfter(t); if(nextStart!=null) els.player.currentTime=nextStart; else els.player.pause(); }
        });
        previewHandlersBound=true;
      }
      bindPreviewHandlers();
      els.player.addEventListener('loadedmetadata', ()=>{ log(`ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—: duration=${(els.player.duration||0).toFixed(2)}s`); });
      els.previewToggle.addEventListener('change',()=>{ previewOn=!!els.previewToggle.checked; if(previewOn && keepSegments.length){ els.player.currentTime=keepSegments[0].start; } });
      els.previewStart.addEventListener('click',()=>{ if(keepSegments.length && previewOn){ els.player.currentTime=keepSegments[0].start; } els.player.play(); });
      els.previewStop.addEventListener('click',()=>{ els.player.pause(); });

      els.wave.addEventListener('click',(e)=>{ if(!analysis) return;
        const rect=els.wave.getBoundingClientRect(); const x=(e.clientX-rect.left)/rect.width; const t=x*analysis.duration;
        if(previewOn){ const seg=withinKeep(t); if(!seg){ const nxt=nextKeepStartAfter(t); if(nxt!=null) els.player.currentTime=nxt; else els.player.pause(); return; } }
        els.player.currentTime=t;
      });

      els.diagBtn.addEventListener('click', async()=>{
        log('[è¨ºæ–­] é–‹å§‹');
        try{
          const canPlayMP4=!!document.createElement('video').canPlayType('video/mp4'); log(`[è¨ºæ–­] MP4 å†ç”Ÿå¯: ${canPlayMP4}`);
          const base = await loadFFmpegLocalWithPrompt(); log(`[è¨ºæ–­] ffmpeg.min.js ãƒ­ãƒ¼ãƒ‰OKï¼ˆbase=${base}ï¼‰`);
          await ensureFFmpeg(); log('[è¨ºæ–­] ffmpeg.wasm åˆ©ç”¨å¯èƒ½'); log('[è¨ºæ–­] æˆåŠŸ');
        }catch(e){ error('[è¨ºæ–­] å¤±æ•—: '+(e?.message||e)); }
        finally{ ensureCutState(); }
      });

      // === ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æŒ™å‹•ã§é€£ç¶šå†ç”Ÿï¼ˆéŒ²ç”»ç”¨ï¼‰ ===
      async function playSegmentsWithSkip(player, segments) {
        if (!segments.length) return;
        let idx = 0;
        const dur = player.duration || (analysis?.duration ?? 0);
        return new Promise((resolve) => {
          let rafId = 0, ended = false;
          function jumpTo(i) {
            if (i >= segments.length) { stop(); return; }
            const s = segments[i];
            player.currentTime = Math.min(Math.max(0, s.start), dur || s.start + 0.001);
            player.play().catch(()=>{});
          }
          function stop() {
            if (ended) return;
            ended = true;
            cancelAnimationFrame(rafId);
            player.pause();
            resolve();
          }
          function tick() {
            if (ended) return;
            const t = player.currentTime;
            const seg = segments[idx];
            if (!(t >= seg.start && t < seg.end)) {
              if (t < seg.start) {
                player.currentTime = seg.start;
              } else {
                idx++;
                if (idx >= segments.length) { stop(); return; }
                player.currentTime = segments[idx].start;
              }
            } else {
              if (t >= seg.end) {
                idx++;
                if (idx >= segments.length) { stop(); return; }
                player.currentTime = segments[idx].start;
              }
            }
            rafId = requestAnimationFrame(tick);
          }
          jumpTo(0); rafId = requestAnimationFrame(tick);
        });
      }

      // === MediaRecorderã§éŒ²ç”»ï¼ˆMP4å„ªå…ˆã€ãªã‘ã‚Œã°WebMâ†’ffmpegã§MP4å¤‰æ›ï¼‰ ===
      async function recordPreviewToMP4(player, segments, preferredName) {
        const prevMuted = player.muted; const prevVolume = player.volume;
        player.muted = false; player.volume = 0;

        const stream = player.captureStream
          ? player.captureStream()
          : (player.mozCaptureStream ? player.mozCaptureStream() : null);
        if (!stream) throw new Error('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ captureStream() ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚');

        const mp4Mime = 'video/mp4;codecs="avc1.42E01E,mp4a.40.2"';
        const webmMimeVp9 = 'video/webm;codecs="vp9,opus"';
        const webmMimeVp8 = 'video/webm;codecs="vp8,opus"';

        let mimeType = '';
        if ('MediaRecorder' in window && MediaRecorder.isTypeSupported(mp4Mime))      mimeType = mp4Mime;
        else if ('MediaRecorder' in window && MediaRecorder.isTypeSupported(webmMimeVp9)) mimeType = webmMimeVp9;
        else if ('MediaRecorder' in window && MediaRecorder.isTypeSupported(webmMimeVp8)) mimeType = webmMimeVp8;
        else throw new Error('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ MediaRecorder éŒ²ç”»ï¼ˆmp4/webmï¼‰ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚');

        const chunks = [];
        const rec = new MediaRecorder(stream, { mimeType });
        rec.ondataavailable = (e)=>{ if (e.data && e.data.size) chunks.push(e.data); };
        const started = new Promise(res => rec.onstart = res);
        const stopped = new Promise(res => rec.onstop = res);

        rec.start(250); await started;
        await playSegmentsWithSkip(player, segments);
        await new Promise(r=>setTimeout(r, 100));
        rec.stop(); await stopped;

        player.muted = prevMuted; player.volume = prevVolume;

        const recordedBlob = new Blob(chunks, { type: rec.mimeType });
        if (rec.mimeType.startsWith('video/mp4')) {
          return { blob: recordedBlob, name: ensureMp4Name(preferredName) };
        }

        await ensureFFmpeg();
        const inputBytes = new Uint8Array(await recordedBlob.arrayBuffer());
        FF_BASE && log(`[convert] WebM -> MP4 (base=${FF_BASE})`);

        const inWbm = 'in.webm', outMp4 = 'rec_out.mp4';
        ffmpeg.FS('writeFile', inWbm, inputBytes);
        await ffmpeg.run(
          '-y','-i', inWbm,
          '-c:v','libx264','-pix_fmt','yuv420p','-preset','veryfast','-crf','22',
          '-c:a','aac','-b:a','192k',
          '-movflags','+faststart',
          outMp4
        );
        const mp4Data = ffmpeg.FS('readFile', outMp4);
        return { blob: new Blob([mp4Data], { type:'video/mp4' }), name: ensureMp4Name(preferredName) };
      }

      function ensureMp4Name(base){
        let name = (base || els.outNameInput.value || 'cut_output.mp4').trim();
        if (!/\.(mp4)$/i.test(name)) name += '.mp4';
        return name;
      }

      async function saveBlobWithPickerOrDownload(blob, name){
        try {
          if ('showSaveFilePicker' in window) {
            const handle = await window.showSaveFilePicker({
              suggestedName: name,
              types: [{ description: 'MP4 Video', accept: { 'video/mp4': ['.mp4'] } }]
            });
            const stream = await handle.createWritable();
            await stream.write(blob); await stream.close();
            log(`ãƒ­ãƒ¼ã‚«ãƒ«ã«ä¿å­˜ã—ã¾ã—ãŸ: ${handle.name}`);
            return;
          }
        } catch(e) {
          error('ä¿å­˜ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒå®Œäº†ã—ã¾ã›ã‚“ã§ã—ãŸã€‚è‡ªå‹•ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚');
        }
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download=name;
        document.body.appendChild(a); a.click(); a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 60000);
        const sizeMB=(blob.size/1e6).toFixed(1);
        els.outWrap.innerHTML = `
          <div class="ok">âœ… æ›¸ãå‡ºã—å®Œäº†: ${sizeMB} MB</div>
          <video controls style="width:100%;max-height:360px;margin-top:8px;border:1px solid #1e2a34;border-radius:10px" src="${url}"></video>
          <div style="margin-top:8px">
            <a download="${name}" href="${url}"><button>ã‚‚ã†ä¸€åº¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button></a>
            <button class="secondary" id="resetBtn">åˆ¥ã®å‹•ç”»ã§ã‚„ã‚Šç›´ã™</button>
          </div>`;
        document.getElementById('resetBtn')?.addEventListener('click',()=>location.reload());
      }

      // ===== ã€Œæ›¸ãå‡ºã—ã€ï¼šãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‘ã‚¹ã®â€œãã®ã¾ã¾éŒ²ç”»â€ã§MP4ä¿å­˜ =====
      els.cut.addEventListener('click', async()=>{
        log('æ›¸ãå‡ºã—é–‹å§‹ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‘ã‚¹ã®â€œãã®ã¾ã¾éŒ²ç”»â€ï¼‰â€¦');
        if(!Array.isArray(keepSegments) || keepSegments.length===0){
          error('ä¿æŒåŒºé–“ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã—ãã„å€¤â†“ / æœ€å°ç„¡éŸ³é•·â†“ ã§å†è¨ˆç®—ã—ã¦ãã ã•ã„ã€‚'); els.segList.scrollIntoView({behavior:'smooth'}); return;
        }
        const f = els.file.files?.[0]; if(!f){ error('å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å‹•ç”»ã‚’é¸æŠâ†’è§£æã—ã¦ãã ã•ã„ã€‚'); return; }

        els.cut.disabled = true; els.recalc.disabled = true; els.analyze.disabled = true; els.prog.style.width='0%';
        try{
          const { blob, name } = await recordPreviewToMP4(els.player, keepSegments, (els.outNameInput.value||'cut_output.mp4'));
          if (!blob || blob.size < 2000) throw new Error(`éŒ²ç”»çµæœãŒå°ã•ã™ãã¾ã™ï¼ˆ${blob?.size||0} bytesï¼‰ã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®éŒ²ç”»åˆ¶é™/æ‹¡å¼µæ©Ÿèƒ½ã®å¹²æ¸‰/DRMã®å¯èƒ½æ€§ã€‚`);
          await saveBlobWithPickerOrDownload(blob, name);
          log('å®Œäº†');
        }catch(e){
          error(e?.message || e);
          log('ï¼ˆãƒ’ãƒ³ãƒˆï¼‰Chromeç­‰ã§ MP4 ç›´éŒ²ä¸å¯ã®ã¨ãã¯ã€WebMéŒ²ç”»â†’ffmpeg.wasmã§MP4å¤‰æ›ã«è‡ªå‹•åˆ‡æ›¿ã—ã¾ã™ã€‚');
        }finally{
          els.recalc.disabled = false; els.analyze.disabled = false; els.cut.disabled = false;
        }
      });

    } // end init guard
  </script>

</body>
</html>
