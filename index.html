<!DOCTYPE html>
<html lang="ja">
<head>
  <!-- PWA / ã‚¢ã‚¤ã‚³ãƒ³é–¢é€£ -->
  <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16.png" />

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ç„¡éŸ³åŒºé–“ã‚ªãƒ¼ãƒˆã‚«ãƒƒãƒˆï¼ˆGitHub Pages / ffmpeg.wasmï¼‰</title>

  <!-- ffmpeg.wasm 0.11.2 -->
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.2/dist/ffmpeg.min.js"></script>

  <!-- COOP/COEP ã‚’ Service Worker ã§ä»˜ä¸ï¼ˆGitHub Pages å¯¾ç­–ï¼‰ -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./coi-serviceworker.js').then(
          () => {
            console.log('coi-serviceworker registered');
          },
          (err) => {
            console.warn('coi-serviceworker registration failed:', err);
          }
        );
      });
    }
  </script>

  <style>
    :root {
      --bg: #05070a;
      --panel: #10141b;
      --panel-soft: #141a23;
      --border: #1f2833;
      --muted: #8aa0b2;
      --text: #eaf2f9;
      --accent: #4aa3ff;
      --accent-soft: rgba(74, 163, 255, 0.15);
      --accent-2: #6ce1a6;
      --warn: #ffb86b;
      --err: #ff6b6b;
      --radius-lg: 16px;
      --radius-md: 10px;
      --shadow-soft: 0 18px 40px rgba(0, 0, 0, 0.55);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font: 14px/1.6 system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        Roboto, "Hiragino Sans", "Noto Sans JP", Arial, sans-serif;
      background: radial-gradient(circle at top, #182235 0, #05070a 55%);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 14px 20px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(12px);
      background: linear-gradient(
          135deg,
          rgba(88, 204, 255, 0.12),
          rgba(88, 204, 255, 0) 40%
        ),
        rgba(5, 7, 10, 0.9);
      position: sticky;
      top: 0;
      z-index: 20;
    }

    header .header-inner {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    header .logo {
      max-width: 260px;
    }

    header .logo svg {
      display: block;
      width: 100%;
      height: auto;
    }

    h1 {
      margin: 0 0 2px;
      font-size: 18px;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    h1 span.badge {
      font-size: 11px;
      padding: 2px 8px 1px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--accent-2);
      background: rgba(108, 225, 166, 0.08);
    }

    header p {
      margin: 0;
      font-size: 12px;
      color: var(--muted);
    }

    main {
      padding: 16px 16px 32px;
      max-width: 1200px;
      width: 100%;
      margin: 0 auto;
      display: grid;
      gap: 16px;
      grid-template-columns: minmax(0, 3fr) minmax(0, 2fr);
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .panel {
      background: radial-gradient(circle at top left, #1c2637 0, #10141b 52%);
      border: 1px solid rgba(255, 255, 255, 0.04);
      border-radius: var(--radius-lg);
      padding: 14px 14px 16px;
      box-shadow: var(--shadow-soft);
      position: relative;
      overflow: hidden;
    }

    .panel::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(
        circle at top right,
        rgba(74, 163, 255, 0.16),
        transparent 55%
      );
      opacity: 0.35;
      mix-blend-mode: soft-light;
      pointer-events: none;
    }

    .panel-inner {
      position: relative;
      z-index: 1;
    }

    .panel h2 {
      margin: 0 0 4px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .step-tag {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      border-radius: 5px;
      background: rgba(10, 14, 19, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.12);
      font-size: 11px;
      color: var(--accent);
    }

    .panel p.desc {
      margin: 0 0 10px;
      font-size: 12px;
      color: var(--muted);
    }

    .field-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }

    .field-label {
      font-size: 12px;
      color: var(--muted);
    }

    input[type="file"] {
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(5, 7, 10, 0.7);
      color: var(--text);
      cursor: pointer;
    }

    input[type="file"]::-webkit-file-upload-button {
      border: none;
      margin-right: 8px;
      border-radius: 999px;
      padding: 4px 10px;
      background: linear-gradient(135deg, var(--accent), #7ad0ff);
      color: #02050a;
      font-size: 11px;
      cursor: pointer;
    }

    video {
      width: 100%;
      max-height: 260px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: #000;
    }

    .file-meta {
      font-size: 11px;
      color: var(--muted);
      margin-top: 6px;
    }

    .slider-group {
      margin-bottom: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(6, 10, 18, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.04);
    }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 6px;
      flex-wrap: wrap;
    }

    .slider-row:last-child {
      margin-bottom: 0;
    }

    .slider-label {
      font-size: 12px;
      color: var(--muted);
      min-width: 106px;
    }

    .slider-value {
      font-size: 12px;
      color: var(--accent-2);
      min-width: 55px;
    }

    input[type="range"] {
      flex: 1;
      appearance: none;
      height: 4px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #02050a;
      box-shadow: 0 0 0 4px rgba(74, 163, 255, 0.3);
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #02050a;
      box-shadow: 0 0 0 4px rgba(74, 163, 255, 0.3);
      cursor: pointer;
    }

    .preset-row {
      margin-top: 4px;
      gap: 6px;
      align-items: center;
    }

    .preset-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .preset-btn {
      font-size: 11px;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(5, 7, 10, 0.9);
      color: var(--muted);
      cursor: pointer;
      transition: background 0.12s ease, color 0.12s ease, border-color 0.12s ease;
    }

    .preset-btn-active {
      border-color: var(--accent-2);
      color: var(--accent-2);
      background: rgba(108, 225, 166, 0.15);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      letter-spacing: 0.01em;
      transition: transform 0.12s ease, box-shadow 0.12s ease,
        background 0.12s ease, opacity 0.12s ease;
      background: linear-gradient(135deg, var(--accent), #65d2ff);
      color: #02050a;
      box-shadow: 0 10px 24px rgba(30, 144, 255, 0.55);
    }

    .btn:disabled {
      opacity: 0.4;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    .btn:not(:disabled):active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 4px 12px rgba(30, 144, 255, 0.5);
    }

    .btn-secondary {
      background: rgba(5, 7, 10, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: var(--muted);
      box-shadow: none;
    }

    .btn-secondary:not(:disabled):hover {
      background: rgba(8, 12, 19, 0.95);
    }

    .btn-icon {
      font-size: 14px;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin: 4px 0 8px;
    }

    .chip {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(5, 7, 10, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .chip-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: var(--accent-2);
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      margin-bottom: 8px;
    }

    .stat-card {
      padding: 8px 9px;
      border-radius: 10px;
      background: rgba(4, 7, 12, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-size: 11px;
    }

    .stat-label {
      color: var(--muted);
      margin-bottom: 2px;
    }

    .stat-value {
      font-size: 13px;
      font-weight: 500;
    }

    .stat-value.accent {
      color: var(--accent-2);
    }

    .stat-value.warn {
      color: var(--warn);
    }

    .segments-list {
      max-height: 160px;
      overflow: auto;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(5, 7, 11, 0.95);
      padding: 6px 0;
      font-size: 11px;
    }

    .segments-empty {
      font-size: 11px;
      color: var(--muted);
      padding: 6px 8px;
    }

    .segment-item {
      padding: 4px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px dashed rgba(255, 255, 255, 0.04);
    }

    .segment-item:last-child {
      border-bottom: none;
    }

    .segment-main {
      display: flex;
      flex-direction: column;
      gap: 1px;
    }

    .segment-title {
      font-weight: 500;
      font-size: 11px;
    }

    .segment-sub {
      font-size: 10px;
      color: var(--muted);
    }

    .segment-right {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }

    .segment-duration {
      font-size: 11px;
      color: var(--accent-2);
      white-space: nowrap;
    }

    .segment-toggle-label {
      font-size: 11px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 3px;
      white-space: nowrap;
    }

    .segment-toggle-label input {
      margin: 0;
    }

    .segment-disabled {
      opacity: 0.45;
    }

    .status-text {
      font-size: 11px;
      color: var(--muted);
      margin-top: 6px;
      min-height: 16px;
    }

    .status-text strong {
      color: var(--accent);
    }

    .status-text.warn {
      color: var(--warn);
    }

    .status-text.err {
      color: var(--err);
    }

    .progress-bar {
      position: relative;
      height: 4px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.05);
      overflow: hidden;
      margin-top: 6px;
      flex: 1;
    }

    .progress-bar-inner {
      position: absolute;
      inset: 0;
      transform-origin: left center;
      transform: scaleX(0);
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      transition: transform 0.12s ease-out;
    }

    .progress-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
    }

    .progress-label {
      font-size: 11px;
      color: var(--muted);
      min-width: 54px;
      text-align: right;
    }

    .log-panel {
      grid-column: span 2;
      max-height: 220px;
    }

    @media (max-width: 900px) {
      .log-panel {
        grid-column: span 1;
      }
    }

    textarea#log {
      width: 100%;
      min-height: 120px;
      max-height: 160px;
      resize: vertical;
      padding: 8px 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      background: rgba(4, 6, 10, 0.96);
      color: var(--muted);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    a#downloadLink {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      margin-top: 8px;
      color: var(--accent-2);
      text-decoration: none;
    }

    a#downloadLink:hover {
      text-decoration: underline;
    }

    .pill {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: var(--muted);
    }

    .output-preview {
      margin-top: 10px;
    }

    .hist-wrap {
      margin-top: 8px;
      padding: 6px 8px 8px;
      border-radius: 10px;
      background: rgba(4, 7, 12, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .hist-title {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .hist-legend {
      font-size: 10px;
      color: var(--muted);
    }

    canvas#timelineCanvas {
      cursor: pointer;
    }

    /* ãƒ˜ãƒ«ãƒ—ã‚¢ã‚¤ã‚³ãƒ³ */
    .help-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      margin-left: 4px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.3);
      font-size: 11px;
      color: var(--muted);
      cursor: help;
      position: relative;
    }

    .help-tooltip {
      position: absolute;
      left: 50%;
      top: 130%;
      transform: translate(-50%, -4px);
      background: #05070a;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      padding: 6px 8px;
      width: 230px;
      max-width: 76vw;
      font-size: 11px;
      color: var(--muted);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.7);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.12s ease, transform 0.12s ease;
      z-index: 10;
      line-height: 1.4;
    }

    .help-icon:hover .help-tooltip,
    .help-icon:focus-within .help-tooltip {
      opacity: 1;
      transform: translate(-50%, 0);
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-inner">
      <!-- ãƒ­ã‚´ -->
      <div class="logo">
        <!-- ã“ã“ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè²¼ã£ãŸSVGãƒ­ã‚´ã‚’ãã®ã¾ã¾å…¥ã‚Œã¦OK -->
        <!-- çœç•¥ã®ãŸã‚ã‚«ãƒƒãƒˆã—ã¾ã—ãŸãŒã€å®Ÿéš›ã«ã¯ã‚ãªãŸã®SVGã‚’ã“ã“ã«å…¥ã‚Œã¦ãã ã•ã„ -->
      </div>

      <div>
        <h1>
          ç„¡éŸ³åŒºé–“ã‚ªãƒ¼ãƒˆã‚«ãƒƒãƒˆ
          <span class="badge">browser + ffmpeg.wasm</span>
        </h1>
        <p>è©±ã—ã¦ã„ãªã„éƒ¨åˆ†ï¼ˆæŒ‡å®šdBæœªæº€ï¼‰ã‚’è‡ªå‹•æ¤œå‡ºã—ã€ã¾ã¨ã‚ã¦ã‚«ãƒƒãƒˆã—ãŸå‹•ç”»ã‚’æ›¸ãå‡ºã—ã¾ã™ã€‚</p>
      </div>
    </div>
  </header>

  <main>
    <!-- å·¦ï¼šå…¥åŠ›ãƒ»è§£æ -->
    <section class="panel">
      <div class="panel-inner">
        <h2><span class="step-tag">1</span> å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</h2>
        <p class="desc">iPad / ã‚¹ãƒãƒ›ã§æ’®ã£ãŸè¬›ç¾©å‹•ç”»ãªã©ã€ç™ºè©±ã®é–“ã®ã€Œé–“ã€ã‚’è‡ªå‹•ã§è©°ã‚ã¾ã™ã€‚</p>

        <div class="field-row">
          <label class="field-label" for="fileInput">å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ï¼š</label>
          <input id="fileInput" type="file" accept="video/*" />
        </div>
        <div id="fileInfo" class="file-meta">ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ</div>

        <video id="previewVideo" controls playsinline muted style="margin-top:8px;"></video>

        <div class="chips">
          <div class="chip"><span class="chip-dot"></span><span>ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§å®Œçµï¼ˆã‚µãƒ¼ãƒãƒ¼ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¾ã›ã‚“ï¼‰</span></div>
          <div class="chip"><span class="chip-dot"></span><span>Safari / Chromeï¼ˆPC & iPadï¼‰å¯¾å¿œã‚’æƒ³å®š</span></div>
        </div>

        <h2 style="margin-top:10px;"><span class="step-tag">2</span> ç„¡éŸ³åˆ¤å®šã®ã—ãã„å€¤ã‚’èª¿æ•´</h2>
        <p class="desc">ãƒ—ãƒªã‚»ãƒƒãƒˆâ†’å¾®èª¿æ•´â†’æ³¢å½¢ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã§ç¢ºèªã€ã¨ã„ã†æµã‚Œã§ä½¿ãˆã¾ã™ã€‚</p>

        <div class="slider-group">
          <!-- ã—ãã„å€¤ï¼ˆdBï¼‰ï¼‹ãƒ˜ãƒ«ãƒ— -->
          <div class="slider-row">
            <div class="slider-label">
              ã—ãã„å€¤ï¼ˆdBï¼‰
              <span class="help-icon" tabindex="0">ï¼Ÿ
                <span class="help-tooltip">
                  50msã”ã¨ã«éŸ³é‡ã‚’dBã§æ¸¬ã‚Šã€ã“ã®å€¤ä»¥ä¸Šã‚’ã€Œå£°ã‚ã‚Šã€ã¨åˆ¤å®šã—ã¾ã™ã€‚<br>
                  ãƒ»å€¤ã‚’å°ã•ãï¼ˆ-60å´ï¼‰ã™ã‚‹ã¨ã€é™ã‹ãªå£°ã‚„ç’°å¢ƒéŸ³ã‚‚æ®‹ã‚Šã‚„ã™ããªã‚Šã¾ã™ã€‚<br>
                  ãƒ»å€¤ã‚’å¤§ããï¼ˆ-10å´ï¼‰ã«ã™ã‚‹ã¨ã€é™ã‹ãªéƒ¨åˆ†ãŒã‚ˆã‚Šã‚«ãƒƒãƒˆã•ã‚Œã‚„ã™ããªã‚Šã¾ã™ã€‚<br>
                  ãƒ—ãƒªã‚»ãƒƒãƒˆã§å¤§ã¾ã‹ã«æ±ºã‚ã¦ã‹ã‚‰ã€ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§å¾®èª¿æ•´ã™ã‚‹ä½¿ã„æ–¹ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ã€‚
                </span>
              </span>
            </div>
            <div class="slider-value" id="thresholdLabel">-35 dB</div>
            <input id="thresholdSlider" type="range" min="-60" max="-10" value="-35" step="1" />
          </div>

          <!-- æœ€å°ç™ºè©±æ™‚é–“ -->
          <div class="slider-row">
            <div class="slider-label">æœ€å°ç™ºè©±æ™‚é–“</div>
            <div class="slider-value" id="minVoiceLabel">0.3 ç§’</div>
            <input id="minVoiceSlider" type="range" min="0.1" max="1.5" value="0.3" step="0.1" />
          </div>

          <!-- å‰å¾Œã®ä½™ç™½ -->
          <div class="slider-row">
            <div class="slider-label">å‰å¾Œã®ä½™ç™½</div>
            <div class="slider-value" id="paddingLabel">0.2 ç§’</div>
            <input id="paddingSlider" type="range" min="0" max="1" value="0.2" step="0.05" />
          </div>
        </div>

        <!-- ãƒ—ãƒªã‚»ãƒƒãƒˆ -->
        <div class="field-row preset-row">
          <div class="field-label">ãƒ—ãƒªã‚»ãƒƒãƒˆï¼š</div>
          <div id="presetButtons" class="preset-buttons"></div>
        </div>

        <!-- dBåˆ†å¸ƒãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ  -->
        <div class="hist-wrap">
          <div class="hist-title">
            <span>éŸ³é‡ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ï¼ˆ50msã”ã¨ã® dB åˆ†å¸ƒï¼‰</span>
            <span class="hist-legend">ç·‘ï¼ã—ãã„å€¤ä»¥ä¸Š / ã‚°ãƒ¬ãƒ¼ï¼ã—ãã„å€¤æœªæº€</span>
          </div>
          <canvas id="histCanvas" width="400" height="120"></canvas>
        </div>

        <!-- æ³¢å½¢ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ -->
        <div class="hist-wrap" style="margin-top:6px;">
          <div class="hist-title">
            <span>æ³¢å½¢ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä½ç½®ã«ã‚¸ãƒ£ãƒ³ãƒ—ï¼‰</span>
            <span class="hist-legend">
              ç·‘ï¼æ®‹ã™åŒºé–“ / ç°è‰²ï¼ã‚«ãƒƒãƒˆåŒºé–“ / ç™½ç·šï¼å†ç”Ÿä½ç½® / é»„ç·šï¼ã‚¯ãƒªãƒƒã‚¯ä½ç½®
            </span>
          </div>
          <canvas id="timelineCanvas" width="400" height="70"></canvas>
        </div>

        <div class="field-row" style="margin-top:10px;">
          <button id="analyzeButton" class="btn btn-secondary">
            <span class="btn-icon">ğŸ”</span>
            éŸ³é‡ã‚’è§£æã™ã‚‹
          </button>
          <span class="pill">â€» åˆå›è§£ææ™‚ã«éŸ³å£°ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ã¾ã™</span>
        </div>

        <div class="field-row" style="margin-top:6px;">
          <button id="previewCutButton" class="btn btn-secondary" disabled>
            <span class="btn-icon">â–¶ï¸</span>
            ã‚«ãƒƒãƒˆå¾Œã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†ç”Ÿ
          </button>
          <span class="pill">â€» ç„¡éŸ³éƒ¨åˆ†ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ãªãŒã‚‰å†ç”Ÿã—ã¾ã™</span>
        </div>

        <div id="analyzeStatus" class="status-text"></div>

        <h2 style="margin-top:10px;"><span class="step-tag">3</span> è§£æçµæœ</h2>
        <p class="desc">æ¤œå‡ºã•ã‚ŒãŸã€Œè©±ã—ã¦ã„ã‚‹åŒºé–“ã€ã”ã¨ã«ON/OFFã§ãã€æ›¸ãå‡ºã—ã«ã‚‚åæ˜ ã•ã‚Œã¾ã™ã€‚</p>

        <div class="stats" id="statsArea"></div>

        <div id="segmentsContainer" class="segments-list">
          <div class="segments-empty">ã¾ã è§£æãŒè¡Œã‚ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</div>
        </div>
      </div>
    </section>

    <!-- å³ï¼šæ›¸ãå‡ºã— -->
    <section class="panel">
      <div class="panel-inner">
        <h2><span class="step-tag">4</span> ç„¡éŸ³ã‚’ã‚«ãƒƒãƒˆã—ã¦æ›¸ãå‡ºã—</h2>
        <p class="desc">ONã«ãªã£ã¦ã„ã‚‹åŒºé–“ã®ã¿ã‚’ã¤ãªã„ã§ã€ã‚«ãƒƒãƒˆå¾Œã® mp4 ã‚’ç”Ÿæˆã—ã¾ã™ã€‚</p>

        <div class="field-row">
          <button id="exportButton" class="btn" disabled>
            <span class="btn-icon">âœ‚ï¸</span>
            ç„¡éŸ³ã‚’ã‚«ãƒƒãƒˆã—ã¦æ›¸ãå‡ºã—
          </button>
          <span class="pill">â€» é•·ã„å‹•ç”»ã¯æ•°åç§’ï½æ•°åˆ†ã‹ã‹ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™</span>
        </div>

        <!-- å¼·åŒ–ç‰ˆãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ -->
        <div class="progress-row">
          <div class="progress-bar">
            <div id="exportProgress" class="progress-bar-inner"></div>
          </div>
          <div id="exportProgressLabel" class="progress-label">0%</div>
        </div>

        <div id="exportStatus" class="status-text"></div>

        <a id="downloadLink" href="#" download="cut-output.mp4" style="display:none;">
          <span>â¬‡ï¸ ã‚«ãƒƒãƒˆå¾Œå‹•ç”»ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</span>
        </a>

        <div class="output-preview">
          <video id="outputVideo" controls playsinline style="display:none;"></video>
        </div>

        <h2 style="margin-top:14px;"><span class="step-tag">â„¹</span> è£œè¶³</h2>
        <p class="desc">
          ãƒ»ãƒ–ãƒ©ã‚¦ã‚¶ã§ ffmpeg-core.wasmï¼ˆç´„ 20ã€œ30MBï¼‰ã‚’èª­ã¿è¾¼ã‚“ã§å‡¦ç†ã™ã‚‹ãŸã‚ã€åˆå›ãƒ­ãƒ¼ãƒ‰ã«æ™‚é–“ãŒã‹ã‹ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚<br/>
          ãƒ»GitHub Pages ä¸Šã§å‹•ã‹ã™å ´åˆã€å¿…è¦ã«å¿œã˜ã¦ ffmpeg-core ã‚’ãƒªãƒã‚¸ãƒˆãƒªå†…ã«é…ç½®ã—ã€
          <code>corePath</code> ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‘ã‚¹ã«å¤‰æ›´ã—ã¦ãŠãã¨å®‰å®šã—ã¾ã™ã€‚
        </p>
      </div>
    </section>

    <!-- ãƒ­ã‚° -->
    <section class="panel log-panel">
      <div class="panel-inner">
        <h2><span class="step-tag">â–¶</span> å†…éƒ¨ãƒ­ã‚°</h2>
        <p class="desc">ãƒˆãƒ©ãƒ–ãƒ«æ™‚ã®ãƒ‡ãƒãƒƒã‚°ç”¨ã§ã™ï¼ˆffmpeg ã®ãƒ­ã‚°ã‚‚ã“ã“ã«å‡ºã¾ã™ï¼‰ã€‚</p>
        <textarea id="log" readonly></textarea>
      </div>
    </section>
  </main>

  <script>
    // DOMå–å¾—
    const fileInput = document.getElementById('fileInput');
    const fileInfo  = document.getElementById('fileInfo');
    const previewVideo = document.getElementById('previewVideo');

    const thresholdSlider = document.getElementById('thresholdSlider');
    const minVoiceSlider  = document.getElementById('minVoiceSlider');
    const paddingSlider   = document.getElementById('paddingSlider');

    const thresholdLabel = document.getElementById('thresholdLabel');
    const minVoiceLabel  = document.getElementById('minVoiceLabel');
    const paddingLabel   = document.getElementById('paddingLabel');

    const analyzeButton = document.getElementById('analyzeButton');
    const analyzeStatus = document.getElementById('analyzeStatus');

    const statsArea          = document.getElementById('statsArea');
    const segmentsContainer  = document.getElementById('segmentsContainer');

    const previewCutButton = document.getElementById('previewCutButton');

    const exportButton       = document.getElementById('exportButton');
    const exportStatus       = document.getElementById('exportStatus');
    const exportProgress     = document.getElementById('exportProgress');
    const exportProgressLabel= document.getElementById('exportProgressLabel');
    const downloadLink       = document.getElementById('downloadLink');
    const outputVideo        = document.getElementById('outputVideo');

    const logArea = document.getElementById('log');

    const histCanvas     = document.getElementById('histCanvas');
    const histCtx        = histCanvas.getContext('2d');
    const timelineCanvas = document.getElementById('timelineCanvas');
    const timelineCtx    = timelineCanvas.getContext('2d');

    const presetButtonsContainer = document.getElementById('presetButtons');

    // çŠ¶æ…‹
    let selectedFile     = null;
    let audioBuffer      = null;
    let detectedSegments = [];
    let ffmpeg           = null;
    let ffmpegLoaded     = false;

    let previewPlaying       = false;
    let previewSegmentIndex  = 0;

    let windowRms    = null;
    let windowFlags  = null;
    let windowDuration = 0.05;

    const HIST_MIN_DB = -80;
    const HIST_MAX_DB = 0;
    const HIST_BINS   = 80;
    let dbHistogram   = null;

    let clickMarkerTime = null;
    let isExportRunning = false;

    // åŒºé–“ ON/OFF ç”¨
    let segmentEnabled  = [];
    let previewSegments = [];

    // ãƒ—ãƒªã‚»ãƒƒãƒˆ
    const PRESETS = [
      { id: 'quiet',  label: 'é™ã‹ãªæ•™å®¤', threshold: -45 },
      { id: 'normal', label: 'ãµã¤ã†',     threshold: -35 },
      { id: 'noisy',  label: 'ã–ã‚ã–ã‚',   threshold: -28 }
    ];
    let activePresetId = 'custom';

    function log(message) {
      const time = new Date().toISOString().split('T')[1].replace('Z', '');
      logArea.value += `[${time}] ${message}\n`;
      logArea.scrollTop = logArea.scrollHeight;
    }

    function updateSliderLabels() {
      thresholdLabel.textContent = `${thresholdSlider.value} dB`;
      minVoiceLabel.textContent  = `${Number(minVoiceSlider.value).toFixed(1)} ç§’`;
      paddingLabel.textContent   = `${Number(paddingSlider.value).toFixed(2)} ç§’`;
    }
    updateSliderLabels();

    function getActiveSegments() {
      if (!detectedSegments || !detectedSegments.length) return [];
      if (!segmentEnabled || segmentEnabled.length !== detectedSegments.length) {
        return detectedSegments.slice();
      }
      const result = [];
      for (let i = 0; i < detectedSegments.length; i++) {
        if (segmentEnabled[i]) result.push(detectedSegments[i]);
      }
      return result;
    }

    // ãƒ—ãƒªã‚»ãƒƒãƒˆUI
    function buildPresetButtons() {
      PRESETS.forEach(p => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = p.label;
        btn.className = 'preset-btn';
        btn.dataset.id = p.id;
        btn.addEventListener('click', () => {
          thresholdSlider.value = String(p.threshold);
          updateSliderLabels();
          activePresetId = p.id;
          updatePresetActiveStyles();
          if (audioBuffer) {
            stopPreview();
            runSegmentationOnly();
          } else {
            renderHistogram(Number(thresholdSlider.value));
            renderTimeline();
          }
        });
        presetButtonsContainer.appendChild(btn);
      });
      updateActivePresetFromThreshold();
    }

    function updatePresetActiveStyles() {
      const buttons = presetButtonsContainer.querySelectorAll('.preset-btn');
      buttons.forEach(btn => {
        if (btn.dataset.id === activePresetId) {
          btn.classList.add('preset-btn-active');
        } else {
          btn.classList.remove('preset-btn-active');
        }
      });
    }

    function updateActivePresetFromThreshold() {
      const t = Number(thresholdSlider.value);
      const preset = PRESETS.find(p => p.threshold === t);
      activePresetId = preset ? preset.id : 'custom';
      updatePresetActiveStyles();
    }

    // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
    thresholdSlider.addEventListener('input', () => {
      updateSliderLabels();
      updateActivePresetFromThreshold();
      if (audioBuffer) {
        stopPreview();
        runSegmentationOnly();
      } else {
        renderHistogram(Number(thresholdSlider.value));
        renderTimeline();
      }
    });
    minVoiceSlider.addEventListener('input', () => {
      updateSliderLabels();
      if (audioBuffer) {
        stopPreview();
        runSegmentationOnly();
      }
    });
    paddingSlider.addEventListener('input', () => {
      updateSliderLabels();
      if (audioBuffer) {
        stopPreview();
        runSegmentationOnly();
      }
    });

    // ffmpeg
    function initFFmpegInstance() {
      if (ffmpeg) return ffmpeg;
      const { createFFmpeg, fetchFile } = FFmpeg;
      ffmpeg = createFFmpeg({
        log: true,
        corePath: 'https://unpkg.com/@ffmpeg/core-st@0.11.1/dist/ffmpeg-core.js',
        mainName: 'main',
        progress: (p) => {
          if (!p || typeof p.ratio !== 'number') return;
          const r = Math.max(0, Math.min(1, p.ratio));
          exportProgress.style.transform = `scaleX(${r})`;
          if (isExportRunning) {
            exportProgressLabel.textContent = `${Math.round(r * 100)}%`;
            if (r < 1) {
              exportStatus.textContent = `æ›¸ãå‡ºã—ä¸­â€¦ ${Math.round(r * 100)}%`;
            }
          }
        }
      });
      ffmpeg._fetchFile = fetchFile;
      return ffmpeg;
    }

    async function ensureFFmpegLoaded() {
      initFFmpegInstance();
      if (!ffmpegLoaded) {
        log('ffmpeg-core ã‚’ãƒ­ãƒ¼ãƒ‰ä¸­â€¦');
        exportStatus.textContent = 'ffmpeg-core ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ã„ã¾ã™â€¦ï¼ˆåˆå›ã®ã¿æ•°åç§’ã‹ã‹ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ï¼‰';
        try {
          await ffmpeg.load();
          ffmpegLoaded = true;
          log('ffmpeg-core ã®ãƒ­ãƒ¼ãƒ‰å®Œäº†');
        } catch (err) {
          console.error(err);
          log('ffmpeg-core ã®ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
          exportStatus.textContent = 'ffmpeg-core ã®ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç’°å¢ƒã‚’ã”ç¢ºèªãã ã•ã„ã€‚';
          throw err;
        }
      }
    }

    // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ
    fileInput.addEventListener('change', () => {
      const file = fileInput.files && fileInput.files[0];
      if (!file) return;

      selectedFile     = file;
      audioBuffer      = null;
      detectedSegments = [];
      segmentEnabled   = [];
      previewSegments  = [];
      dbHistogram      = null;
      windowRms        = null;
      windowFlags      = null;
      clickMarkerTime  = null;
      clearHistogram();
      clearTimeline();

      stopPreview();
      analyzeStatus.textContent = '';
      analyzeStatus.classList.remove('warn', 'err');
      statsArea.innerHTML = '';
      segmentsContainer.innerHTML = '<div class="segments-empty">ã¾ã è§£æãŒè¡Œã‚ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</div>';
      exportButton.disabled       = true;
      previewCutButton.disabled   = true;
      exportStatus.textContent    = '';
      exportStatus.classList.remove('warn', 'err');
      exportProgress.style.transform = 'scaleX(0)';
      exportProgressLabel.textContent = '0%';
      downloadLink.style.display  = 'none';
      outputVideo.style.display   = 'none';
      outputVideo.removeAttribute('src');

      const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
      fileInfo.textContent = `${file.name}ï¼ˆ${sizeMB} MBï¼‰`;

      const url = URL.createObjectURL(file);
      previewVideo.src = url;
      previewVideo.play().catch(() => {});

      log(`å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ: ${file.name} (${sizeMB}MB)`);
    });

    // éŸ³å£°ãƒ‡ã‚³ãƒ¼ãƒ‰
    async function decodeAudioIfNeeded() {
      if (audioBuffer) return audioBuffer;
      if (!selectedFile) throw new Error('å…ˆã«å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');

      analyzeStatus.textContent = 'éŸ³å£°ãƒˆãƒ©ãƒƒã‚¯ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ä¸­â€¦';
      analyzeStatus.classList.remove('warn', 'err');
      log('AudioContext ã§éŸ³å£°ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰é–‹å§‹');

      const arrayBuffer = await selectedFile.arrayBuffer();
      const AudioCtx = window.AudioContext || window.webkitAudioContext;

      if (AudioCtx) {
        const audioCtx = new AudioCtx();
        try {
          const decoded = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
          audioBuffer = decoded;
          analyzeStatus.textContent =
            `éŸ³å£°ãƒ‡ã‚³ãƒ¼ãƒ‰å®Œäº†ï¼šé•·ã• ${decoded.duration.toFixed(2)} ç§’ï¼ˆAudioContextï¼‰`;
          log(`AudioContext ã§ãƒ‡ã‚³ãƒ¼ãƒ‰æˆåŠŸ: duration=${decoded.duration.toFixed(2)}sec, sampleRate=${decoded.sampleRate}`);
          return audioBuffer;
        } catch (err) {
          log(`AudioContext ã«ã‚ˆã‚‹ãƒ‡ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—: ${err.message || err}`);
          log('â†’ ffmpeg.wasm ã§è§£æç”¨ PCM ã‚’ç”Ÿæˆã—ã¦ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ã€‚');
        } finally {
          if (audioCtx && typeof audioCtx.close === 'function') {
            audioCtx.close();
          }
        }
      } else {
        log('AudioContext ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚ç›´æ¥ ffmpeg.wasm ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¾ã™ã€‚');
      }

      analyzeStatus.textContent = 'ffmpeg ã§éŸ³å£°ãƒˆãƒ©ãƒƒã‚¯ã‚’æŠ½å‡ºä¸­â€¦';
      log('ffmpeg ã§ mono 48kHz PCM ã‚’ç”Ÿæˆé–‹å§‹');

      await ensureFFmpegLoaded();
      const fetchFile = ffmpeg._fetchFile;
      const inputExt  = (selectedFile.name.split('.').pop() || 'mp4').toLowerCase();
      const inputName = `analysis-input.${inputExt}`;
      const pcmName   = 'analysis-audio.pcm';

      try {
        ffmpeg.FS('writeFile', inputName, await fetchFile(selectedFile));
        await ffmpeg.run(
          '-i', inputName,
          '-vn',
          '-ac', '1',
          '-ar', '48000',
          '-f', 'f32le',
          pcmName
        );
        const data = ffmpeg.FS('readFile', pcmName);
        const dv   = new DataView(data.buffer, data.byteOffset, data.byteLength);
        const samples   = data.byteLength / 4;
        const floatData = new Float32Array(samples);
        for (let i = 0; i < samples; i++) {
          floatData[i] = dv.getFloat32(i * 4, true);
        }

        const sampleRate = 48000;
        const duration   = samples / sampleRate;
        audioBuffer = {
          sampleRate,
          duration,
          numberOfChannels: 1,
          getChannelData: (ch) => {
            if (ch !== 0) throw new Error('mono ãƒãƒƒãƒ•ã‚¡ãªã®ã§ ch=0 ã®ã¿');
            return floatData;
          }
        };

        analyzeStatus.textContent =
          `éŸ³å£°æŠ½å‡ºå®Œäº†ï¼ˆffmpegä½¿ç”¨ï¼‰ï¼šé•·ã• ${duration.toFixed(2)} ç§’`;
        log(`ffmpeg è§£æç”¨ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªç”Ÿæˆå®Œäº†: duration=${duration.toFixed(2)}sec, sampleRate=${sampleRate}`);
        return audioBuffer;
      } catch (err) {
        log(`ffmpeg ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§ã‚‚éŸ³å£°æŠ½å‡ºã«å¤±æ•—: ${err.message || err}`);
        throw err;
      } finally {
        try { ffmpeg.FS('unlink', pcmName); } catch (_) {}
        try { ffmpeg.FS('unlink', inputName); } catch (_) {}
      }
    }

    // ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ  & ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³
    function clearHistogram() {
      if (!histCtx) return;
      const w = histCanvas.width;
      const h = histCanvas.height;
      histCtx.clearRect(0, 0, w, h);
      histCtx.fillStyle = '#05070a';
      histCtx.fillRect(0, 0, w, h);
      histCtx.fillStyle = 'rgba(255,255,255,0.3)';
      histCtx.font = '10px system-ui';
      histCtx.fillText('è§£æå¾Œã«éŸ³é‡åˆ†å¸ƒãŒè¡¨ç¤ºã•ã‚Œã¾ã™', 8, h / 2);
    }

    function clearTimeline() {
      if (!timelineCtx) return;
      const w = timelineCanvas.width;
      const h = timelineCanvas.height;
      timelineCtx.clearRect(0, 0, w, h);
      timelineCtx.fillStyle = '#05070a';
      timelineCtx.fillRect(0, 0, w, h);
      timelineCtx.fillStyle = 'rgba(255,255,255,0.3)';
      timelineCtx.font = '10px system-ui';
      timelineCtx.fillText('è§£æå¾Œã«æ³¢å½¢ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãŒè¡¨ç¤ºã•ã‚Œã¾ã™', 8, h / 2);
    }

    function renderHistogram(thresholdDb) {
      if (!histCtx) return;
      const w = histCanvas.width;
      const h = histCanvas.height;

      histCtx.clearRect(0, 0, w, h);
      histCtx.fillStyle = '#05070a';
      histCtx.fillRect(0, 0, w, h);

      histCtx.strokeStyle = 'rgba(255,255,255,0.05)';
      histCtx.lineWidth = 1;
      histCtx.beginPath();
      for (let i = 1; i <= 4; i++) {
        const y = (h - 20) * (i / 4);
        histCtx.moveTo(0, y);
        histCtx.lineTo(w, y);
      }
      histCtx.stroke();

      if (!dbHistogram || !dbHistogram.totalBins || dbHistogram.countWindows <= 0) {
        histCtx.fillStyle = 'rgba(255,255,255,0.3)';
        histCtx.font = '10px system-ui';
        histCtx.fillText('è§£æå¾Œã«éŸ³é‡åˆ†å¸ƒãŒè¡¨ç¤ºã•ã‚Œã¾ã™', 8, h / 2);
        return;
      }

      const totalBins = dbHistogram.totalBins;
      const maxCount = Math.max(...totalBins, 1);
      const barAreaHeight = h - 20;
      const dx = w / totalBins.length;

      for (let i = 0; i < totalBins.length; i++) {
        const count = totalBins[i];
        if (count === 0) continue;
        const ratio = count / maxCount;
        const barH = ratio * (barAreaHeight * 0.95);

        const binCenterRatio = (i + 0.5) / totalBins.length;
        const dbCenter = HIST_MIN_DB + binCenterRatio * (HIST_MAX_DB - HIST_MIN_DB);

        if (dbCenter >= thresholdDb) {
          histCtx.fillStyle = 'rgba(108,225,166,0.9)';
        } else {
          histCtx.fillStyle = 'rgba(255,255,255,0.25)';
        }

        const x = i * dx;
        const y = barAreaHeight - barH;
        histCtx.fillRect(x, y, Math.max(1, dx - 0.5), barH);
      }

      const tRatio = (thresholdDb - HIST_MIN_DB) / (HIST_MAX_DB - HIST_MIN_DB);
      const tX = Math.max(0, Math.min(w, tRatio * w));

      histCtx.strokeStyle = 'rgba(74,163,255,0.9)';
      histCtx.lineWidth = 1.2;
      histCtx.beginPath();
      histCtx.moveTo(tX, 0);
      histCtx.lineTo(tX, barAreaHeight + 2);
      histCtx.stroke();

      histCtx.fillStyle = 'rgba(74,163,255,0.95)';
      histCtx.font = '10px system-ui';
      const label = `${thresholdDb.toFixed(0)} dB`;
      histCtx.fillText(label, Math.min(Math.max(2, tX + 4), w - 40), 10);

      histCtx.fillStyle = 'rgba(255,255,255,0.5)';
      histCtx.font = '9px system-ui';
      histCtx.fillText(`${HIST_MIN_DB} dB`, 4, h - 6);
      const zeroX = w * ((0 - HIST_MIN_DB) / (HIST_MAX_DB - HIST_MIN_DB));
      histCtx.fillText('0 dB', Math.min(w - 30, zeroX - 12), h - 6);
    }

    function renderTimeline() {
      if (!timelineCtx) return;
      const w = timelineCanvas.width;
      const h = timelineCanvas.height;

      timelineCtx.clearRect(0, 0, w, h);
      timelineCtx.fillStyle = '#05070a';
      timelineCtx.fillRect(0, 0, w, h);

      if (!audioBuffer || !windowRms || !windowFlags || !windowRms.length) {
        timelineCtx.fillStyle = 'rgba(255,255,255,0.3)';
        timelineCtx.font = '10px system-ui';
        timelineCtx.fillText('è§£æå¾Œã«æ³¢å½¢ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãŒè¡¨ç¤ºã•ã‚Œã¾ã™', 8, h / 2);
        return;
      }

      const N = windowRms.length;
      const maxRms = Math.max(...windowRms, 1e-6);
      const dx = w / N;

      for (let i = 0; i < N; i++) {
        const rms = windowRms[i];
        const amp = rms / maxRms;
        const loud = windowFlags[i];

        let alphaBase, alpha;
        if (loud) {
          alphaBase = 0.25;
          alpha = alphaBase + amp * 0.55;
          timelineCtx.fillStyle = `rgba(108,225,166,${alpha.toFixed(3)})`;
        } else {
          alphaBase = 0.05;
          alpha = alphaBase + amp * 0.35;
          timelineCtx.fillStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;
        }

        const x = i * dx;
        const barW = Math.max(1, dx + 0.5);
        timelineCtx.fillRect(x, 0, barW, h);
      }

      const dur = audioBuffer.duration;
      timelineCtx.fillStyle = 'rgba(255,255,255,0.7)';
      timelineCtx.font = '9px system-ui';
      timelineCtx.fillText('0s', 4, h - 4);
      const label = dur.toFixed(1) + 's';
      timelineCtx.fillText(label, w - 40, h - 4);

      if (!isNaN(previewVideo.currentTime) && dur > 0) {
        const playRatio = Math.max(0, Math.min(1, previewVideo.currentTime / dur));
        const playX = playRatio * w;
        timelineCtx.strokeStyle = 'rgba(255,255,255,0.95)';
        timelineCtx.lineWidth = 1.5;
        timelineCtx.beginPath();
        timelineCtx.moveTo(playX, 0);
        timelineCtx.lineTo(playX, h);
        timelineCtx.stroke();
      }

      if (clickMarkerTime != null && dur > 0) {
        const clickRatio = Math.max(0, Math.min(1, clickMarkerTime / dur));
        const clickX = clickRatio * w;
        timelineCtx.strokeStyle = 'rgba(255,220,0,0.95)';
        timelineCtx.lineWidth = 1.3;
        timelineCtx.setLineDash([4, 3]);
        timelineCtx.beginPath();
        timelineCtx.moveTo(clickX, 0);
        timelineCtx.lineTo(clickX, h);
        timelineCtx.stroke();
        timelineCtx.setLineDash([]);
      }
    }

    // ç„¡éŸ³åŒºé–“è§£æ
    function computeSegmentsFromAudioBuffer(buffer, thresholdDb, minVoiceSec, paddingSec) {
      const duration   = buffer.duration;
      const sampleRate = buffer.sampleRate;
      const channelData = buffer.getChannelData(0);

      const winDur  = 0.05;
      const winSize = Math.floor(sampleRate * winDur);
      const totalWindows = Math.floor(channelData.length / winSize);

      const loudFlags = new Array(totalWindows);
      const rmsArr    = new Array(totalWindows);
      const totalBins = new Array(HIST_BINS).fill(0);

      for (let i = 0; i < totalWindows; i++) {
        let sumSq = 0;
        const offset = i * winSize;
        for (let j = 0; j < winSize; j++) {
          const s = channelData[offset + j];
          sumSq += s * s;
        }
        const rms = Math.sqrt(sumSq / winSize);
        rmsArr[i] = rms;

        let db = rms <= 1e-8 ? -Infinity : 20 * Math.log10(rms);
        if (!isFinite(db)) db = HIST_MIN_DB;
        const clamped = Math.max(HIST_MIN_DB, Math.min(HIST_MAX_DB, db));
        let r   = (clamped - HIST_MIN_DB) / (HIST_MAX_DB - HIST_MIN_DB);
        let idx = Math.floor(r * HIST_BINS);
        if (idx < 0) idx = 0;
        if (idx >= HIST_BINS) idx = HIST_BINS - 1;

        totalBins[idx]++;

        const isLoud = db >= thresholdDb;
        loudFlags[i] = isLoud;
      }

      windowRms      = rmsArr;
      windowFlags    = loudFlags;
      windowDuration = winDur;
      dbHistogram    = {
        totalBins,
        countWindows: totalWindows
      };

      renderHistogram(thresholdDb);
      renderTimeline();

      const segments = [];
      let inSegment = false;
      let segStart  = 0;
      for (let i = 0; i < totalWindows; i++) {
        const t = i * winDur;
        if (loudFlags[i] && !inSegment) {
          inSegment = true;
          segStart  = t;
        } else if (!loudFlags[i] && inSegment) {
          const segEnd = i * winDur;
          if (segEnd - segStart >= minVoiceSec) {
            segments.push({ start: segStart, end: segEnd });
          }
          inSegment = false;
        }
      }
      if (inSegment) {
        const segEnd = totalWindows * winDur;
        if (segEnd - segStart >= minVoiceSec) {
          segments.push({ start: segStart, end: segEnd });
        }
      }

      const padded = segments.map(seg => ({
        start: Math.max(0, seg.start - paddingSec),
        end:   Math.min(duration, seg.end + paddingSec)
      }));

      padded.sort((a, b) => a.start - b.start);
      const merged = [];
      for (const seg of padded) {
        if (!merged.length) {
          merged.push({ ...seg });
        } else {
          const last = merged[merged.length - 1];
          if (seg.start <= last.end) {
            last.end = Math.max(last.end, seg.end);
          } else {
            merged.push({ ...seg });
          }
        }
      }
      return merged;
    }

    function formatTime(sec) {
      const s = Math.max(0, sec);
      const m = Math.floor(s / 60);
      const r = s - m * 60;
      if (m === 0) return `${r.toFixed(2)}ç§’`;
      return `${m}åˆ†${r.toFixed(1)}ç§’`;
    }

    function refreshStatsAndSegmentsUI() {
      statsArea.innerHTML = '';
      segmentsContainer.innerHTML = '';

      if (!audioBuffer) {
        segmentsContainer.innerHTML = '<div class="segments-empty">ã¾ã è§£æãŒè¡Œã‚ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</div>';
        return;
      }

      const original      = audioBuffer.duration;
      const activeSegments= getActiveSegments();
      const totalKept     = activeSegments.reduce((sum, seg) => sum + (seg.end - seg.start), 0);
      const ratio         = original > 0 ? (totalKept / original) : 0;

      const statHtml = `
        <div class="stat-card">
          <div class="stat-label">å…ƒå‹•ç”»ã®é•·ã•</div>
          <div class="stat-value">${formatTime(original)}</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">ã‚«ãƒƒãƒˆå¾Œã®é•·ã•</div>
          <div class="stat-value accent">${formatTime(totalKept)}</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">æ®‹ã™å‰²åˆï¼ˆç›®å®‰ï¼‰</div>
          <div class="stat-value ${ratio < 0.4 ? 'warn' : ''}">${(ratio * 100).toFixed(1)} %</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">åŒºé–“æ•°ï¼ˆæ¤œå‡º / æœ‰åŠ¹ï¼‰</div>
          <div class="stat-value">${detectedSegments.length} / ${activeSegments.length}</div>
        </div>
      `;
      statsArea.innerHTML = statHtml;

      if (!detectedSegments.length) {
        segmentsContainer.innerHTML =
          '<div class="segments-empty">ç™ºè©±åŒºé–“ãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ã—ãã„å€¤ï¼ˆdBï¼‰ã‚’ä¸‹ã’ã¦å†è§£æã—ã¦ã¿ã¦ãã ã•ã„ã€‚</div>';
        return;
      }

      const frag = document.createDocumentFragment();
      detectedSegments.forEach((seg, idx) => {
        const li = document.createElement('div');
        li.className = 'segment-item';

        const enabled = !segmentEnabled.length || segmentEnabled[idx];

        if (!enabled) {
          li.classList.add('segment-disabled');
        }

        const main = document.createElement('div');
        main.className = 'segment-main';

        const title = document.createElement('div');
        title.className = 'segment-title';
        title.textContent = `#${idx + 1}  ${seg.start.toFixed(2)}s ã€œ ${seg.end.toFixed(2)}s`;

        const sub   = document.createElement('div');
        sub.className = 'segment-sub';
        const len   = seg.end - seg.start;
        sub.textContent = `é•·ã•ï¼š${len.toFixed(2)}ç§’`;

        main.appendChild(title);
        main.appendChild(sub);

        const right = document.createElement('div');
        right.className = 'segment-right';

        const dur = document.createElement('div');
        dur.className = 'segment-duration';
        dur.textContent = `+${len.toFixed(2)} s`;

        const label = document.createElement('label');
        label.className = 'segment-toggle-label';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = enabled;
        checkbox.addEventListener('change', () => {
          if (!segmentEnabled.length || segmentEnabled.length !== detectedSegments.length) {
            segmentEnabled = detectedSegments.map(() => true);
          }
          segmentEnabled[idx] = checkbox.checked;
          previewSegments = getActiveSegments();
          refreshStatsAndSegmentsUI();
          renderTimeline();
        });
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode('ä½¿ç”¨'));

        right.appendChild(dur);
        right.appendChild(label);

        li.appendChild(main);
        li.appendChild(right);

        frag.appendChild(li);
      });

      segmentsContainer.appendChild(frag);
    }

    async function runFullAnalysis() {
      if (!selectedFile) {
        alert('å…ˆã«å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
        return;
      }
      analyzeButton.disabled = true;
      analyzeStatus.classList.remove('warn', 'err');
      analyzeStatus.textContent = 'éŸ³å£°è§£æã‚’å®Ÿè¡Œä¸­â€¦';

      try {
        const buffer   = await decodeAudioIfNeeded();
        const threshold= Number(thresholdSlider.value);
        const minVoice = Number(minVoiceSlider.value);
        const padding  = Number(paddingSlider.value);

        log(`ç„¡éŸ³åˆ¤å®š: threshold=${threshold}dB, minVoice=${minVoice}s, padding=${padding}s`);
        detectedSegments = computeSegmentsFromAudioBuffer(
          buffer,
          threshold,
          minVoice,
          padding
        );

        segmentEnabled  = detectedSegments.map(() => true);
        previewSegments = getActiveSegments();

        analyzeStatus.textContent = `è§£æå®Œäº†ï¼šæ¤œå‡ºåŒºé–“ ${detectedSegments.length} å€‹`;
        if (!detectedSegments.length) {
          analyzeStatus.classList.add('warn');
          analyzeStatus.textContent += 'ï¼ˆã—ãã„å€¤ã‚’ä¸‹ã’ã¦å†è§£æã—ã¦ã¿ã¦ãã ã•ã„ï¼‰';
        }

        refreshStatsAndSegmentsUI();
        exportButton.disabled     = previewSegments.length === 0;
        previewCutButton.disabled = previewSegments.length === 0;
      } catch (err) {
        console.error(err);
        log(`è§£æã‚¨ãƒ©ãƒ¼: ${err.message || err}`);
        analyzeStatus.textContent = `è§£æã‚¨ãƒ©ãƒ¼: ${err.message || err}`;
        analyzeStatus.classList.add('err');
        exportButton.disabled     = true;
        previewCutButton.disabled = true;
      } finally {
        analyzeButton.disabled = false;
      }
    }

    function runSegmentationOnly() {
      if (!audioBuffer) return;
      const threshold = Number(thresholdSlider.value);
      const minVoice  = Number(minVoiceSlider.value);
      const padding   = Number(paddingSlider.value);

      log(`ï¼ˆå†è§£æï¼‰threshold=${threshold}dB, minVoice=${minVoice}s, padding=${padding}s`);
      detectedSegments = computeSegmentsFromAudioBuffer(
        audioBuffer,
        threshold,
        minVoice,
        padding
      );
      segmentEnabled  = detectedSegments.map(() => true);
      previewSegments = getActiveSegments();

      analyzeStatus.textContent = `è§£ææ›´æ–°ï¼šæ¤œå‡ºåŒºé–“ ${detectedSegments.length} å€‹`;
      if (!detectedSegments.length) {
        analyzeStatus.classList.add('warn');
        analyzeStatus.textContent += 'ï¼ˆã—ãã„å€¤ã‚’ä¸‹ã’ã¦å†è§£æã—ã¦ã¿ã¦ãã ã•ã„ï¼‰';
      } else {
        analyzeStatus.classList.remove('warn', 'err');
      }
      refreshStatsAndSegmentsUI();
      exportButton.disabled     = previewSegments.length === 0;
      previewCutButton.disabled = previewSegments.length === 0;
    }

    analyzeButton.addEventListener('click', () => {
      stopPreview();
      runFullAnalysis();
    });

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
    function startPreview() {
      const segs = (previewSegments && previewSegments.length) ? previewSegments : getActiveSegments();
      if (!segs.length || !previewVideo.src) {
        alert('æœ‰åŠ¹ãªåŒºé–“ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
        return;
      }
      previewSegments     = segs;
      previewPlaying      = true;
      previewSegmentIndex = 0;
      previewCutButton.innerHTML = '<span class="btn-icon">â¹</span> ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åœæ­¢';

      const firstStart = segs[0].start;
      previewVideo.currentTime = Math.max(0, firstStart + 0.02);
      previewVideo.muted = false;
      previewVideo.play().catch(() => {});
    }

    function stopPreview() {
      if (!previewPlaying) {
        previewCutButton.innerHTML = '<span class="btn-icon">â–¶ï¸</span> ã‚«ãƒƒãƒˆå¾Œã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†ç”Ÿ';
        return;
      }
      previewPlaying      = false;
      previewSegmentIndex = 0;
      previewCutButton.innerHTML = '<span class="btn-icon">â–¶ï¸</span> ã‚«ãƒƒãƒˆå¾Œã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†ç”Ÿ';
      try { previewVideo.pause(); } catch (_) {}
      renderTimeline();
    }

    previewCutButton.addEventListener('click', () => {
      if (!detectedSegments.length) return;
      if (previewPlaying) {
        stopPreview();
      } else {
        startPreview();
      }
    });

    previewVideo.addEventListener('timeupdate', () => {
      if (audioBuffer && windowRms) {
        renderTimeline();
      }

      if (!previewPlaying || !previewSegments.length) return;
      const cur = previewVideo.currentTime;
      const seg = previewSegments[previewSegmentIndex];
      if (!seg) {
        stopPreview();
        return;
      }
      const end = seg.end;
      if (cur >= end - 0.03) {
        previewSegmentIndex++;
        const nextSeg = previewSegments[previewSegmentIndex];
        if (!nextSeg) {
          stopPreview();
        } else {
          previewVideo.currentTime = Math.max(0, nextSeg.start + 0.02);
        }
      }
    });

    previewVideo.addEventListener('pause', () => {
      if (previewPlaying && previewVideo.seeking === false) {
        previewPlaying = false;
        previewCutButton.innerHTML = '<span class="btn-icon">â–¶ï¸</span> ã‚«ãƒƒãƒˆå¾Œã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†ç”Ÿ';
        renderTimeline();
      }
    });

    // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¯ãƒªãƒƒã‚¯
    timelineCanvas.addEventListener('click', (e) => {
      if (!audioBuffer || !windowRms) return;
      const rect = timelineCanvas.getBoundingClientRect();
      const x    = e.clientX - rect.left;
      const ratio= Math.max(0, Math.min(1, x / timelineCanvas.width));
      const targetTime = ratio * audioBuffer.duration;

      clickMarkerTime = targetTime;

      if (!detectedSegments.length) {
        previewVideo.currentTime = targetTime;
        previewVideo.play().catch(() => {});
        renderTimeline();
        return;
      }

      const segs = (previewSegments && previewSegments.length) ? previewSegments : getActiveSegments();

      if (previewPlaying) {
        let idx = segs.findIndex(seg => seg.end > targetTime);
        if (idx === -1) {
          stopPreview();
          renderTimeline();
          return;
        }
        previewSegments     = segs;
        previewSegmentIndex = idx;
        const start = segs[idx].start;
        previewVideo.currentTime = Math.max(0, start + 0.02);
        previewVideo.play().catch(() => {});
      } else {
        previewVideo.currentTime = targetTime;
        previewVideo.play().catch(() => {});
      }
      renderTimeline();
    });

    // filter_complex
    function buildFilterComplex(segments) {
      if (!segments.length) {
        throw new Error('æ›¸ãå‡ºã—å¯¾è±¡ã®åŒºé–“ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
      }

      const vParts       = [];
      const aParts       = [];
      const concatInputs = [];

      segments.forEach((seg, idx) => {
        const start = seg.start.toFixed(3);
        const end   = seg.end.toFixed(3);
        vParts.push(`[0:v]trim=start=${start}:end=${end},setpts=PTS-STARTPTS[v${idx}]`);
        aParts.push(`[0:a]atrim=start=${start}:end=${end},asetpts=PTS-STARTPTS[a${idx}]`);
        concatInputs.push(`[v${idx}][a${idx}]`);
      });

      const concat = `${concatInputs.join('')}concat=n=${segments.length}:v=1:a=1[v][a]`;
      const filter = `${vParts.join(';')};${aParts.join(';')};${concat}`;
      log(`filter_complex: ${filter}`);
      return filter;
    }

    // æ›¸ãå‡ºã—
    async function exportVideo() {
      if (!selectedFile) {
        alert('å…ˆã«å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
        return;
      }
      const segmentsForExport = (previewSegments && previewSegments.length)
        ? previewSegments
        : getActiveSegments();
      if (!segmentsForExport.length) {
        alert('æœ‰åŠ¹ãªåŒºé–“ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã—ãã„å€¤ã‚„åŒºé–“ã®ON/OFFã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        return;
      }

      stopPreview();

      exportButton.disabled = true;
      isExportRunning       = true;
      exportProgress.style.transform = 'scaleX(0)';
      exportProgressLabel.textContent = '0%';
      exportStatus.textContent = 'æ›¸ãå‡ºã—æº–å‚™ä¸­â€¦';
      exportStatus.classList.remove('warn', 'err');
      downloadLink.style.display = 'none';
      outputVideo.style.display  = 'none';
      outputVideo.removeAttribute('src');

      try {
        await ensureFFmpegLoaded();

        const inputExt  = (selectedFile.name.split('.').pop() || 'mp4').toLowerCase();
        const inputName = `input.${inputExt}`;
        const outputName= 'output.mp4';

        log('ffmpeg FS ã«å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸ãè¾¼ã¿');
        const fetchFile = ffmpeg._fetchFile;
        ffmpeg.FS('writeFile', inputName, await fetchFile(selectedFile));

        const filterComplex = buildFilterComplex(segmentsForExport);

        exportStatus.textContent = 'å†ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰å‡¦ç†ä¸­â€¦ 0%';
        log(`ffmpeg.run -i ${inputName} ...`);

        await ffmpeg.run(
          '-i', inputName,
          '-filter_complex', filterComplex,
          '-map', '[v]', '-map', '[a]',
          '-preset', 'veryfast',
          '-crf', '23',
          '-movflags', '+faststart',
          outputName
        );

        exportProgress.style.transform = 'scaleX(1)';
        exportProgressLabel.textContent = '100%';

        log('ffmpeg å‡ºåŠ›èª­ã¿è¾¼ã¿');
        const data = ffmpeg.FS('readFile', outputName);
        const blob = new Blob([data.buffer], { type: 'video/mp4' });
        const url  = URL.createObjectURL(blob);

        downloadLink.href = url;
        downloadLink.style.display = 'inline-flex';
        downloadLink.download = `cut-${selectedFile.name.replace(/\.[^.]+$/, '')}.mp4`;
        outputVideo.src = url;
        outputVideo.style.display = 'block';

        const original  = audioBuffer ? audioBuffer.duration : 0;
        const totalKept = segmentsForExport.reduce((sum, seg) => sum + (seg.end - seg.start), 0);
        exportStatus.textContent =
          `æ›¸ãå‡ºã—å®Œäº†ï¼š${formatTime(original)} â†’ ${formatTime(totalKept)} ã«çŸ­ç¸®ã•ã‚Œã¾ã—ãŸã€‚`;
        log('æ›¸ãå‡ºã—å®Œäº†');
      } catch (err) {
        console.error(err);
        exportStatus.textContent = `æ›¸ãå‡ºã—ã‚¨ãƒ©ãƒ¼: ${err.message || err}`;
        exportStatus.classList.add('err');
        log(`æ›¸ãå‡ºã—ã‚¨ãƒ©ãƒ¼: ${err.message || err}`);
      } finally {
        try { ffmpeg.FS('unlink', 'output.mp4'); } catch (_) {}
        try {
          const inputExt = (selectedFile.name.split('.').pop() || 'mp4').toLowerCase();
          ffmpeg.FS('unlink', `input.${inputExt}`);
        } catch (_) {}
        isExportRunning       = false;
        exportButton.disabled = false;
      }
    }

    exportButton.addEventListener('click', () => {
      exportVideo();
    });

    // åˆæœŸè¡¨ç¤º
    buildPresetButtons();
    clearHistogram();
    clearTimeline();
  </script>
</body>
</html>
